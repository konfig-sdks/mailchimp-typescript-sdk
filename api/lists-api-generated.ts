/* tslint:disable */
/* eslint-disable */
/*
Mailchimp Marketing API

Mailchimp is a marketing platform for small businesses. It offers an all-in-one marketing solution that includes email marketing, ads, landing pages, and automation. With Mailchimp, businesses can design and send targeted campaigns, analyze their performance, and grow their audience.

The version of the OpenAPI document: 3.0.55
Contact: apihelp@mailchimp.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddListMembers } from '../models';
// @ts-ignore
import { CampaignDefaultsProperty } from '../models';
// @ts-ignore
import { CollectionOfContentForListSignupForms } from '../models';
// @ts-ignore
import { CollectionOfElementStyleForListSignupForms } from '../models';
// @ts-ignore
import { ConditionsProperty } from '../models';
// @ts-ignore
import { ConditionsProperty1 } from '../models';
// @ts-ignore
import { EventsProperty } from '../models';
// @ts-ignore
import { ListContactProperty } from '../models';
// @ts-ignore
import { ListContactProperty1 } from '../models';
// @ts-ignore
import { ListsAddInterestCategory200Response } from '../models';
// @ts-ignore
import { ListsAddInterestCategoryRequest } from '../models';
// @ts-ignore
import { ListsAddInterestCategoryResponse } from '../models';
// @ts-ignore
import { ListsAddInterestCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsAddInterestInCategory200Response } from '../models';
// @ts-ignore
import { ListsAddInterestInCategoryRequest } from '../models';
// @ts-ignore
import { ListsAddInterestInCategoryResponse } from '../models';
// @ts-ignore
import { ListsAddInterestInCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMemberEventRequest } from '../models';
// @ts-ignore
import { ListsAddMemberEventResponse } from '../models';
// @ts-ignore
import { ListsAddMemberEventdefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMemberNote200Response } from '../models';
// @ts-ignore
import { ListsAddMemberNoteRequest } from '../models';
// @ts-ignore
import { ListsAddMemberNoteResponse } from '../models';
// @ts-ignore
import { ListsAddMemberNotedefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMemberTagsRequest } from '../models';
// @ts-ignore
import { ListsAddMemberTagsResponse } from '../models';
// @ts-ignore
import { ListsAddMemberTagsdefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMemberToList200Response } from '../models';
// @ts-ignore
import { ListsAddMemberToListRequest } from '../models';
// @ts-ignore
import { ListsAddMemberToListResponse } from '../models';
// @ts-ignore
import { ListsAddMemberToListdefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMemberToSegment200Response } from '../models';
// @ts-ignore
import { ListsAddMemberToSegmentRequest } from '../models';
// @ts-ignore
import { ListsAddMemberToSegmentResponse } from '../models';
// @ts-ignore
import { ListsAddMemberToSegmentdefaultResponse } from '../models';
// @ts-ignore
import { ListsAddMergeField200Response } from '../models';
// @ts-ignore
import { ListsAddMergeFieldRequest } from '../models';
// @ts-ignore
import { ListsAddMergeFieldResponse } from '../models';
// @ts-ignore
import { ListsAddMergeFielddefaultResponse } from '../models';
// @ts-ignore
import { ListsAddNewSegment200Response } from '../models';
// @ts-ignore
import { ListsAddNewSegmentRequest } from '../models';
// @ts-ignore
import { ListsAddNewSegmentResponse } from '../models';
// @ts-ignore
import { ListsAddNewSegmentdefaultResponse } from '../models';
// @ts-ignore
import { ListsAddOrUpdateMember200Response } from '../models';
// @ts-ignore
import { ListsAddOrUpdateMemberRequest } from '../models';
// @ts-ignore
import { ListsAddOrUpdateMemberResponse } from '../models';
// @ts-ignore
import { ListsAddOrUpdateMemberdefaultResponse } from '../models';
// @ts-ignore
import { ListsArchiveMemberResponse } from '../models';
// @ts-ignore
import { ListsArchiveMemberdefaultResponse } from '../models';
// @ts-ignore
import { ListsBatchAddRemoveMembers200Response } from '../models';
// @ts-ignore
import { ListsBatchAddRemoveMembersRequest } from '../models';
// @ts-ignore
import { ListsBatchAddRemoveMembersResponse } from '../models';
// @ts-ignore
import { ListsBatchAddRemoveMembersdefaultResponse } from '../models';
// @ts-ignore
import { ListsBatchSubscribeOrUnsubscribe200Response } from '../models';
// @ts-ignore
import { ListsBatchSubscribeOrUnsubscribeRequest } from '../models';
// @ts-ignore
import { ListsBatchSubscribeOrUnsubscribeResponse } from '../models';
// @ts-ignore
import { ListsBatchSubscribeOrUnsubscribedefaultResponse } from '../models';
// @ts-ignore
import { ListsCreateNewList200Response } from '../models';
// @ts-ignore
import { ListsCreateNewListRequest } from '../models';
// @ts-ignore
import { ListsCreateNewListResponse } from '../models';
// @ts-ignore
import { ListsCreateNewListdefaultResponse } from '../models';
// @ts-ignore
import { ListsCreateWebhook200Response } from '../models';
// @ts-ignore
import { ListsCreateWebhookRequest } from '../models';
// @ts-ignore
import { ListsCreateWebhookResponse } from '../models';
// @ts-ignore
import { ListsCreateWebhookdefaultResponse } from '../models';
// @ts-ignore
import { ListsCustomizeSignupForm200Response } from '../models';
// @ts-ignore
import { ListsCustomizeSignupFormRequest } from '../models';
// @ts-ignore
import { ListsCustomizeSignupFormResponse } from '../models';
// @ts-ignore
import { ListsCustomizeSignupFormdefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteInterestCategoryResponse } from '../models';
// @ts-ignore
import { ListsDeleteInterestCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteInterestInCategoryResponse } from '../models';
// @ts-ignore
import { ListsDeleteInterestInCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteListResponse } from '../models';
// @ts-ignore
import { ListsDeleteListdefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteMergeFieldResponse } from '../models';
// @ts-ignore
import { ListsDeleteMergeFielddefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteNoteResponse } from '../models';
// @ts-ignore
import { ListsDeleteNotedefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteSegmentResponse } from '../models';
// @ts-ignore
import { ListsDeleteSegmentdefaultResponse } from '../models';
// @ts-ignore
import { ListsDeleteWebhookResponse } from '../models';
// @ts-ignore
import { ListsDeleteWebhookdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetAbuseReport200Response } from '../models';
// @ts-ignore
import { ListsGetAbuseReportResponse } from '../models';
// @ts-ignore
import { ListsGetAbuseReportdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetAllAbuseReports200Response } from '../models';
// @ts-ignore
import { ListsGetAllAbuseReportsResponse } from '../models';
// @ts-ignore
import { ListsGetAllAbuseReportsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetAllInfo200Response } from '../models';
// @ts-ignore
import { ListsGetAllInfoResponse } from '../models';
// @ts-ignore
import { ListsGetAllInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryByMonth200Response } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryByMonthResponse } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryByMonthdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryData200Response } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryDataResponse } from '../models';
// @ts-ignore
import { ListsGetGrowthHistoryDatadefaultResponse } from '../models';
// @ts-ignore
import { ListsGetInterestCategoryInfo200Response } from '../models';
// @ts-ignore
import { ListsGetInterestCategoryInfoResponse } from '../models';
// @ts-ignore
import { ListsGetInterestCategoryInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetInterestInCategory200Response } from '../models';
// @ts-ignore
import { ListsGetInterestInCategoryResponse } from '../models';
// @ts-ignore
import { ListsGetInterestInCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsGetListInfo200Response } from '../models';
// @ts-ignore
import { ListsGetListInfoResponse } from '../models';
// @ts-ignore
import { ListsGetListInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetLocations200Response } from '../models';
// @ts-ignore
import { ListsGetLocationsResponse } from '../models';
// @ts-ignore
import { ListsGetLocationsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberEvents200Response } from '../models';
// @ts-ignore
import { ListsGetMemberEventsResponse } from '../models';
// @ts-ignore
import { ListsGetMemberEventsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberGoals200Response } from '../models';
// @ts-ignore
import { ListsGetMemberGoalsResponse } from '../models';
// @ts-ignore
import { ListsGetMemberGoalsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberInfo200Response } from '../models';
// @ts-ignore
import { ListsGetMemberInfoResponse } from '../models';
// @ts-ignore
import { ListsGetMemberInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberNote200Response } from '../models';
// @ts-ignore
import { ListsGetMemberNoteResponse } from '../models';
// @ts-ignore
import { ListsGetMemberNotedefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberNotes200Response } from '../models';
// @ts-ignore
import { ListsGetMemberNotesResponse } from '../models';
// @ts-ignore
import { ListsGetMemberNotesdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMemberTags200Response } from '../models';
// @ts-ignore
import { ListsGetMemberTagsResponse } from '../models';
// @ts-ignore
import { ListsGetMemberTagsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMembersInfo200Response } from '../models';
// @ts-ignore
import { ListsGetMembersInfoResponse } from '../models';
// @ts-ignore
import { ListsGetMembersInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetMergeFieldInfo200Response } from '../models';
// @ts-ignore
import { ListsGetMergeFieldInfoResponse } from '../models';
// @ts-ignore
import { ListsGetMergeFieldInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetRecentActivityStats200Response } from '../models';
// @ts-ignore
import { ListsGetRecentActivityStatsResponse } from '../models';
// @ts-ignore
import { ListsGetRecentActivityStatsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentInfo200Response } from '../models';
// @ts-ignore
import { ListsGetSegmentInfoResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentMembers200Response } from '../models';
// @ts-ignore
import { ListsGetSegmentMembersResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentMembersdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentsInfo200Response } from '../models';
// @ts-ignore
import { ListsGetSegmentsInfoResponse } from '../models';
// @ts-ignore
import { ListsGetSegmentsInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSignupForms200Response } from '../models';
// @ts-ignore
import { ListsGetSignupFormsResponse } from '../models';
// @ts-ignore
import { ListsGetSignupFormsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSurveyDetailsResponse } from '../models';
// @ts-ignore
import { ListsGetSurveyDetailsdefaultResponse } from '../models';
// @ts-ignore
import { ListsGetSurveysInfoResponse } from '../models';
// @ts-ignore
import { ListsGetSurveysInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetWebhookInfo200Response } from '../models';
// @ts-ignore
import { ListsGetWebhookInfoResponse } from '../models';
// @ts-ignore
import { ListsGetWebhookInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsGetWebhooksInfo200Response } from '../models';
// @ts-ignore
import { ListsGetWebhooksInfoResponse } from '../models';
// @ts-ignore
import { ListsGetWebhooksInfodefaultResponse } from '../models';
// @ts-ignore
import { ListsListCategoryInterests200Response } from '../models';
// @ts-ignore
import { ListsListCategoryInterestsResponse } from '../models';
// @ts-ignore
import { ListsListCategoryInterestsdefaultResponse } from '../models';
// @ts-ignore
import { ListsListInterestCategories200Response } from '../models';
// @ts-ignore
import { ListsListInterestCategoriesResponse } from '../models';
// @ts-ignore
import { ListsListInterestCategoriesdefaultResponse } from '../models';
// @ts-ignore
import { ListsListMergeFields200Response } from '../models';
// @ts-ignore
import { ListsListMergeFieldsResponse } from '../models';
// @ts-ignore
import { ListsListMergeFieldsdefaultResponse } from '../models';
// @ts-ignore
import { ListsListTopEmailClients200Response } from '../models';
// @ts-ignore
import { ListsListTopEmailClientsResponse } from '../models';
// @ts-ignore
import { ListsListTopEmailClientsdefaultResponse } from '../models';
// @ts-ignore
import { ListsRemoveMemberFromSegmentResponse } from '../models';
// @ts-ignore
import { ListsRemoveMemberFromSegmentdefaultResponse } from '../models';
// @ts-ignore
import { ListsRemoveMemberPermanentResponse } from '../models';
// @ts-ignore
import { ListsRemoveMemberPermanentdefaultResponse } from '../models';
// @ts-ignore
import { ListsSearchTagsByName200Response } from '../models';
// @ts-ignore
import { ListsSearchTagsByNameResponse } from '../models';
// @ts-ignore
import { ListsSearchTagsByNamedefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategory200Response } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategoryInterest200Response } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategoryInterestResponse } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategoryInterestdefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategoryResponse } from '../models';
// @ts-ignore
import { ListsUpdateInterestCategorydefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateMember200Response } from '../models';
// @ts-ignore
import { ListsUpdateMemberRequest } from '../models';
// @ts-ignore
import { ListsUpdateMemberResponse } from '../models';
// @ts-ignore
import { ListsUpdateMemberdefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateMergeField200Response } from '../models';
// @ts-ignore
import { ListsUpdateMergeFieldRequest } from '../models';
// @ts-ignore
import { ListsUpdateMergeFieldResponse } from '../models';
// @ts-ignore
import { ListsUpdateMergeFielddefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateNoteSpecificListMember200Response } from '../models';
// @ts-ignore
import { ListsUpdateNoteSpecificListMemberResponse } from '../models';
// @ts-ignore
import { ListsUpdateNoteSpecificListMemberdefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateSegmentById200Response } from '../models';
// @ts-ignore
import { ListsUpdateSegmentByIdRequest } from '../models';
// @ts-ignore
import { ListsUpdateSegmentByIdResponse } from '../models';
// @ts-ignore
import { ListsUpdateSegmentByIddefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateSettings200Response } from '../models';
// @ts-ignore
import { ListsUpdateSettingsRequest } from '../models';
// @ts-ignore
import { ListsUpdateSettingsResponse } from '../models';
// @ts-ignore
import { ListsUpdateSettingsdefaultResponse } from '../models';
// @ts-ignore
import { ListsUpdateWebhookSettings200Response } from '../models';
// @ts-ignore
import { ListsUpdateWebhookSettingsResponse } from '../models';
// @ts-ignore
import { ListsUpdateWebhookSettingsdefaultResponse } from '../models';
// @ts-ignore
import { ListsViewRecentActivity200Response } from '../models';
// @ts-ignore
import { ListsViewRecentActivityEvents200Response } from '../models';
// @ts-ignore
import { ListsViewRecentActivityEventsResponse } from '../models';
// @ts-ignore
import { ListsViewRecentActivityEventsdefaultResponse } from '../models';
// @ts-ignore
import { ListsViewRecentActivityResponse } from '../models';
// @ts-ignore
import { ListsViewRecentActivitydefaultResponse } from '../models';
// @ts-ignore
import { LocationProperty } from '../models';
// @ts-ignore
import { MarketingPermission } from '../models';
// @ts-ignore
import { MemberTag } from '../models';
// @ts-ignore
import { MergeFieldOptionsProperty } from '../models';
// @ts-ignore
import { MergeFieldOptionsProperty1 } from '../models';
// @ts-ignore
import { SignupFormHeaderOptionsProperty } from '../models';
// @ts-ignore
import { SourcesProperty } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ListsApi - axios parameter creator
 * @export
 */
export const ListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new interest category.
         * @summary Add interest category
         * @param {string} listId The unique ID for the list.
         * @param {ListsAddInterestCategoryRequest} listsAddInterestCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInterestCategory: async (listId: string, listsAddInterestCategoryRequest: ListsAddInterestCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addInterestCategory', 'listId', listId)
            // verify required parameter 'listsAddInterestCategoryRequest' is not null or undefined
            assertParamExists('addInterestCategory', 'listsAddInterestCategoryRequest', listsAddInterestCategoryRequest)
            const localVarPath = `/lists/{list_id}/interest-categories`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddInterestCategoryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddInterestCategoryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new interest or \'group name\' for a specific category.
         * @summary Add interest in category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {ListsAddInterestInCategoryRequest} listsAddInterestInCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInterestInCategory: async (listId: string, interestCategoryId: string, listsAddInterestInCategoryRequest: ListsAddInterestInCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addInterestInCategory', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('addInterestInCategory', 'interestCategoryId', interestCategoryId)
            // verify required parameter 'listsAddInterestInCategoryRequest' is not null or undefined
            assertParamExists('addInterestInCategory', 'listsAddInterestInCategoryRequest', listsAddInterestInCategoryRequest)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}/interests`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddInterestInCategoryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}/interests',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddInterestInCategoryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an event for a list member.
         * @summary Add event
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {ListsAddMemberEventRequest} listsAddMemberEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberEvent: async (listId: string, subscriberHash: string, listsAddMemberEventRequest: ListsAddMemberEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMemberEvent', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('addMemberEvent', 'subscriberHash', subscriberHash)
            // verify required parameter 'listsAddMemberEventRequest' is not null or undefined
            assertParamExists('addMemberEvent', 'listsAddMemberEventRequest', listsAddMemberEventRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/events`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberEventRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/events',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberEventRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new note for a specific subscriber.
         * @summary Add member note
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address.
         * @param {ListsAddMemberNoteRequest} listsAddMemberNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberNote: async (listId: string, subscriberHash: string, listsAddMemberNoteRequest: ListsAddMemberNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMemberNote', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('addMemberNote', 'subscriberHash', subscriberHash)
            // verify required parameter 'listsAddMemberNoteRequest' is not null or undefined
            assertParamExists('addMemberNote', 'listsAddMemberNoteRequest', listsAddMemberNoteRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/notes`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberNoteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/notes',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberNoteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove tags from a list member. If a tag that does not exist is passed in and set as \'active\', a new tag will be created.
         * @summary Add or remove member tags
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address.
         * @param {ListsAddMemberTagsRequest} listsAddMemberTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberTags: async (listId: string, subscriberHash: string, listsAddMemberTagsRequest: ListsAddMemberTagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMemberTags', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('addMemberTags', 'subscriberHash', subscriberHash)
            // verify required parameter 'listsAddMemberTagsRequest' is not null or undefined
            assertParamExists('addMemberTags', 'listsAddMemberTagsRequest', listsAddMemberTagsRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/tags`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberTagsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/tags',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberTagsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new member to the list.
         * @summary Add member to list
         * @param {string} listId The unique ID for the list.
         * @param {ListsAddMemberToListRequest} listsAddMemberToListRequest 
         * @param {boolean} [skipMergeValidation] If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToList: async (listId: string, listsAddMemberToListRequest: ListsAddMemberToListRequest, skipMergeValidation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMemberToList', 'listId', listId)
            // verify required parameter 'listsAddMemberToListRequest' is not null or undefined
            assertParamExists('addMemberToList', 'listsAddMemberToListRequest', listsAddMemberToListRequest)
            const localVarPath = `/lists/{list_id}/members`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (skipMergeValidation !== undefined) {
                localVarQueryParameter['skip_merge_validation'] = skipMergeValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberToListRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberToListRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a member to a static segment.
         * @summary Add member to segment
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {ListsAddMemberToSegmentRequest} listsAddMemberToSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToSegment: async (listId: string, segmentId: string, listsAddMemberToSegmentRequest: ListsAddMemberToSegmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMemberToSegment', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('addMemberToSegment', 'segmentId', segmentId)
            // verify required parameter 'listsAddMemberToSegmentRequest' is not null or undefined
            assertParamExists('addMemberToSegment', 'listsAddMemberToSegmentRequest', listsAddMemberToSegmentRequest)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}/members`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberToSegmentRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}/members',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberToSegmentRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new merge field for a specific audience.
         * @summary Add merge field
         * @param {string} listId The unique ID for the list.
         * @param {ListsAddMergeFieldRequest} listsAddMergeFieldRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMergeField: async (listId: string, listsAddMergeFieldRequest: ListsAddMergeFieldRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addMergeField', 'listId', listId)
            // verify required parameter 'listsAddMergeFieldRequest' is not null or undefined
            assertParamExists('addMergeField', 'listsAddMergeFieldRequest', listsAddMergeFieldRequest)
            const localVarPath = `/lists/{list_id}/merge-fields`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMergeFieldRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/merge-fields',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMergeFieldRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new segment in a specific list.
         * @summary Add segment
         * @param {string} listId The unique ID for the list.
         * @param {ListsAddNewSegmentRequest} listsAddNewSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSegment: async (listId: string, listsAddNewSegmentRequest: ListsAddNewSegmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addNewSegment', 'listId', listId)
            // verify required parameter 'listsAddNewSegmentRequest' is not null or undefined
            assertParamExists('addNewSegment', 'listsAddNewSegmentRequest', listsAddNewSegmentRequest)
            const localVarPath = `/lists/{list_id}/segments`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddNewSegmentRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddNewSegmentRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update a list member.
         * @summary Add or update list member
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {ListsAddOrUpdateMemberRequest} listsAddOrUpdateMemberRequest 
         * @param {boolean} [skipMergeValidation] If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateMember: async (listId: string, subscriberHash: string, listsAddOrUpdateMemberRequest: ListsAddOrUpdateMemberRequest, skipMergeValidation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addOrUpdateMember', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('addOrUpdateMember', 'subscriberHash', subscriberHash)
            // verify required parameter 'listsAddOrUpdateMemberRequest' is not null or undefined
            assertParamExists('addOrUpdateMember', 'listsAddOrUpdateMemberRequest', listsAddOrUpdateMemberRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (skipMergeValidation !== undefined) {
                localVarQueryParameter['skip_merge_validation'] = skipMergeValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddOrUpdateMemberRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddOrUpdateMemberRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive a list member. To permanently delete, use the delete-permanent action.
         * @summary Archive list member
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveMember: async (listId: string, subscriberHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('archiveMember', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('archiveMember', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch add/remove list members to static segment
         * @summary Batch add or remove members
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {ListsBatchAddRemoveMembersRequest} listsBatchAddRemoveMembersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAddRemoveMembers: async (listId: string, segmentId: string, listsBatchAddRemoveMembersRequest: ListsBatchAddRemoveMembersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('batchAddRemoveMembers', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('batchAddRemoveMembers', 'segmentId', segmentId)
            // verify required parameter 'listsBatchAddRemoveMembersRequest' is not null or undefined
            assertParamExists('batchAddRemoveMembers', 'listsBatchAddRemoveMembersRequest', listsBatchAddRemoveMembersRequest)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsBatchAddRemoveMembersRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsBatchAddRemoveMembersRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch subscribe or unsubscribe list members.
         * @summary Batch subscribe or unsubscribe
         * @param {string} listId The unique ID for the list.
         * @param {ListsBatchSubscribeOrUnsubscribeRequest} listsBatchSubscribeOrUnsubscribeRequest 
         * @param {boolean} [skipMergeValidation] If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
         * @param {boolean} [skipDuplicateCheck] If skip_duplicate_check is true, we will ignore duplicates sent in the request when using the batch sub/unsub on the lists endpoint. The status of the first appearance in the request will be saved. This defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchSubscribeOrUnsubscribe: async (listId: string, listsBatchSubscribeOrUnsubscribeRequest: ListsBatchSubscribeOrUnsubscribeRequest, skipMergeValidation?: boolean, skipDuplicateCheck?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('batchSubscribeOrUnsubscribe', 'listId', listId)
            // verify required parameter 'listsBatchSubscribeOrUnsubscribeRequest' is not null or undefined
            assertParamExists('batchSubscribeOrUnsubscribe', 'listsBatchSubscribeOrUnsubscribeRequest', listsBatchSubscribeOrUnsubscribeRequest)
            const localVarPath = `/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (skipMergeValidation !== undefined) {
                localVarQueryParameter['skip_merge_validation'] = skipMergeValidation;
            }

            if (skipDuplicateCheck !== undefined) {
                localVarQueryParameter['skip_duplicate_check'] = skipDuplicateCheck;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsBatchSubscribeOrUnsubscribeRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsBatchSubscribeOrUnsubscribeRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new list in your Mailchimp account.
         * @summary Add list
         * @param {ListsCreateNewListRequest} listsCreateNewListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewList: async (listsCreateNewListRequest: ListsCreateNewListRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listsCreateNewListRequest' is not null or undefined
            assertParamExists('createNewList', 'listsCreateNewListRequest', listsCreateNewListRequest)
            const localVarPath = `/lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsCreateNewListRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsCreateNewListRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new webhook for a specific list.
         * @summary Add webhook
         * @param {string} listId The unique ID for the list.
         * @param {ListsCreateWebhookRequest} listsCreateWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (listId: string, listsCreateWebhookRequest: ListsCreateWebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('createWebhook', 'listId', listId)
            // verify required parameter 'listsCreateWebhookRequest' is not null or undefined
            assertParamExists('createWebhook', 'listsCreateWebhookRequest', listsCreateWebhookRequest)
            const localVarPath = `/lists/{list_id}/webhooks`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsCreateWebhookRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/webhooks',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsCreateWebhookRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Customize a list\'s default signup form.
         * @summary Customize signup form
         * @param {string} listId The unique ID for the list.
         * @param {ListsCustomizeSignupFormRequest} listsCustomizeSignupFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customizeSignupForm: async (listId: string, listsCustomizeSignupFormRequest: ListsCustomizeSignupFormRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('customizeSignupForm', 'listId', listId)
            // verify required parameter 'listsCustomizeSignupFormRequest' is not null or undefined
            assertParamExists('customizeSignupForm', 'listsCustomizeSignupFormRequest', listsCustomizeSignupFormRequest)
            const localVarPath = `/lists/{list_id}/signup-forms`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsCustomizeSignupFormRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/signup-forms',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsCustomizeSignupFormRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific interest category.
         * @summary Delete interest category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterestCategory: async (listId: string, interestCategoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteInterestCategory', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('deleteInterestCategory', 'interestCategoryId', interestCategoryId)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete interests or group names in a specific category.
         * @summary Delete interest in category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {string} interestId The specific interest or \&#39;group name\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterestInCategory: async (listId: string, interestCategoryId: string, interestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteInterestInCategory', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('deleteInterestInCategory', 'interestCategoryId', interestCategoryId)
            // verify required parameter 'interestId' is not null or undefined
            assertParamExists('deleteInterestInCategory', 'interestId', interestId)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)))
                .replace(`{${"interest_id"}}`, encodeURIComponent(String(interestId !== undefined ? interestId : `-interest_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a list from your Mailchimp account. If you delete a list, you\'ll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.
         * @summary Delete list
         * @param {string} listId The unique ID for the list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteList: async (listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteList', 'listId', listId)
            const localVarPath = `/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific merge field.
         * @summary Delete merge field
         * @param {string} listId The unique ID for the list.
         * @param {string} mergeId The id for the merge field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMergeField: async (listId: string, mergeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteMergeField', 'listId', listId)
            // verify required parameter 'mergeId' is not null or undefined
            assertParamExists('deleteMergeField', 'mergeId', mergeId)
            const localVarPath = `/lists/{list_id}/merge-fields/{merge_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"merge_id"}}`, encodeURIComponent(String(mergeId !== undefined ? mergeId : `-merge_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/merge-fields/{merge_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific note for a specific list member.
         * @summary Delete note
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {string} noteId The id for the note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (listId: string, subscriberHash: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteNote', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('deleteNote', 'subscriberHash', subscriberHash)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteNote', 'noteId', noteId)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId !== undefined ? noteId : `-note_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific segment in a list.
         * @summary Delete segment
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (listId: string, segmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteSegment', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('deleteSegment', 'segmentId', segmentId)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific webhook in a list.
         * @summary Delete webhook
         * @param {string} listId The unique ID for the list.
         * @param {string} webhookId The webhook\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (listId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteWebhook', 'listId', listId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/lists/{list_id}/webhooks/{webhook_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId !== undefined ? webhookId : `-webhook_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/webhooks/{webhook_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a specific abuse report.
         * @summary Get abuse report
         * @param {string} listId The unique ID for the list.
         * @param {string} reportId The id for the abuse report.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbuseReport: async (listId: string, reportId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getAbuseReport', 'listId', listId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getAbuseReport', 'reportId', reportId)
            const localVarPath = `/lists/{list_id}/abuse-reports/{report_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId !== undefined ? reportId : `-report_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/abuse-reports/{report_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all abuse reports for a specific list.
         * @summary List abuse reports
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAbuseReports: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getAllAbuseReports', 'listId', listId)
            const localVarPath = `/lists/{list_id}/abuse-reports`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/abuse-reports',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all lists in the account.
         * @summary Get lists info
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [beforeDateCreated] Restrict response to lists created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [sinceDateCreated] Restrict results to lists created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeCampaignLastSent] Restrict results to lists created before the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [sinceCampaignLastSent] Restrict results to lists created after the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [email] Restrict results to lists that include a specific subscriber\&#39;s email address.
         * @param {'date_created'} [sortField] Returns files sorted by the specified field.
         * @param {'ASC' | 'DESC'} [sortDir] Determines the order direction for sorted results.
         * @param {boolean} [hasEcommerceStore] Restrict results to lists that contain an active, connected, undeleted ecommerce store.
         * @param {boolean} [includeTotalContacts] Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInfo: async (fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, beforeDateCreated?: string, sinceDateCreated?: string, beforeCampaignLastSent?: string, sinceCampaignLastSent?: string, email?: string, sortField?: 'date_created', sortDir?: 'ASC' | 'DESC', hasEcommerceStore?: boolean, includeTotalContacts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (beforeDateCreated !== undefined) {
                localVarQueryParameter['before_date_created'] = beforeDateCreated;
            }

            if (sinceDateCreated !== undefined) {
                localVarQueryParameter['since_date_created'] = sinceDateCreated;
            }

            if (beforeCampaignLastSent !== undefined) {
                localVarQueryParameter['before_campaign_last_sent'] = beforeCampaignLastSent;
            }

            if (sinceCampaignLastSent !== undefined) {
                localVarQueryParameter['since_campaign_last_sent'] = sinceCampaignLastSent;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sort_field'] = sortField;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (hasEcommerceStore !== undefined) {
                localVarQueryParameter['has_ecommerce_store'] = hasEcommerceStore;
            }

            if (includeTotalContacts !== undefined) {
                localVarQueryParameter['include_total_contacts'] = includeTotalContacts;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of a specific list\'s growth activity for a specific month and year.
         * @summary Get growth history by month
         * @param {string} listId The unique ID for the list.
         * @param {string} month A specific month of list growth history.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrowthHistoryByMonth: async (listId: string, month: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getGrowthHistoryByMonth', 'listId', listId)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getGrowthHistoryByMonth', 'month', month)
            const localVarPath = `/lists/{list_id}/growth-history/{month}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month !== undefined ? month : `-month-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/growth-history/{month}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a month-by-month summary of a specific list\'s growth activity.
         * @summary List growth history data
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {'month'} [sortField] Returns files sorted by the specified field.
         * @param {'ASC' | 'DESC'} [sortDir] Determines the order direction for sorted results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrowthHistoryData: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, sortField?: 'month', sortDir?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getGrowthHistoryData', 'listId', listId)
            const localVarPath = `/lists/{list_id}/growth-history`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sort_field'] = sortField;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/growth-history',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific interest category.
         * @summary Get interest category info
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterestCategoryInfo: async (listId: string, interestCategoryId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getInterestCategoryInfo', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('getInterestCategoryInfo', 'interestCategoryId', interestCategoryId)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get interests or \'group names\' for a specific category.
         * @summary Get interest in category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {string} interestId The specific interest or \&#39;group name\&#39;.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterestInCategory: async (listId: string, interestCategoryId: string, interestId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getInterestInCategory', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('getInterestInCategory', 'interestCategoryId', interestCategoryId)
            // verify required parameter 'interestId' is not null or undefined
            assertParamExists('getInterestInCategory', 'interestId', interestId)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)))
                .replace(`{${"interest_id"}}`, encodeURIComponent(String(interestId !== undefined ? interestId : `-interest_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven\'t confirmed their subscription yet and unsubscribed or cleaned.
         * @summary Get list info
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {boolean} [includeTotalContacts] Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListInfo: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, includeTotalContacts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getListInfo', 'listId', listId)
            const localVarPath = `/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (includeTotalContacts !== undefined) {
                localVarQueryParameter['include_total_contacts'] = includeTotalContacts;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the locations (countries) that the list\'s subscribers have been tagged to based on geocoding their IP address.
         * @summary List locations
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getLocations', 'listId', listId)
            const localVarPath = `/lists/{list_id}/locations`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/locations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get events for a contact.
         * @summary List member events
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberEvents: async (listId: string, subscriberHash: string, count?: number, offset?: number, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberEvents', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberEvents', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/events`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/events',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last 50 Goal events for a member on a specific list.
         * @summary List member goal events
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberGoals: async (listId: string, subscriberHash: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberGoals', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberGoals', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/goals`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/goals',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.
         * @summary Get member info
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInfo: async (listId: string, subscriberHash: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberInfo', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberInfo', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific note for a specific list member.
         * @summary Get member note
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {string} noteId The id for the note.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberNote: async (listId: string, subscriberHash: string, noteId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberNote', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberNote', 'subscriberHash', subscriberHash)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('getMemberNote', 'noteId', noteId)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId !== undefined ? noteId : `-note_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent notes for a specific list member.
         * @summary List recent member notes
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address.
         * @param {'created_at' | 'updated_at' | 'note_id'} [sortField] Returns notes sorted by the specified field.
         * @param {'ASC' | 'DESC'} [sortDir] Determines the order direction for sorted results.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberNotes: async (listId: string, subscriberHash: string, sortField?: 'created_at' | 'updated_at' | 'note_id', sortDir?: 'ASC' | 'DESC', fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberNotes', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberNotes', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/notes`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (sortField !== undefined) {
                localVarQueryParameter['sort_field'] = sortField;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/notes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tags on a list member.
         * @summary List member tags
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberTags: async (listId: string, subscriberHash: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMemberTags', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('getMemberTags', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/tags`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about members in a specific Mailchimp list.
         * @summary List members info
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [emailType] The email type.
         * @param {'subscribed' | 'unsubscribed' | 'cleaned' | 'pending' | 'transactional' | 'archived'} [status] The subscriber\&#39;s status.
         * @param {string} [sinceTimestampOpt] Restrict results to subscribers who opted-in after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeTimestampOpt] Restrict results to subscribers who opted-in before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [sinceLastChanged] Restrict results to subscribers whose information changed after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeLastChanged] Restrict results to subscribers whose information changed before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [uniqueEmailId] A unique identifier for the email address across all Mailchimp lists.
         * @param {boolean} [vipOnly] A filter to return only the list\&#39;s VIP members. Passing &#x60;true&#x60; will restrict results to VIP list members, passing &#x60;false&#x60; will return all list members.
         * @param {string} [interestCategoryId] The unique id for the interest category.
         * @param {string} [interestIds] Used to filter list members by interests. Must be accompanied by interest_category_id and interest_match. The value must be a comma separated list of interest ids present for any supplied interest categories.
         * @param {'any' | 'all' | 'none'} [interestMatch] Used to filter list members by interests. Must be accompanied by interest_category_id and interest_ids. \&quot;any\&quot; will match a member with any of the interest supplied, \&quot;all\&quot; will only match members with every interest supplied, and \&quot;none\&quot; will match members without any of the interest supplied.
         * @param {'timestamp_opt' | 'timestamp_signup' | 'last_changed'} [sortField] Returns files sorted by the specified field.
         * @param {'ASC' | 'DESC'} [sortDir] Determines the order direction for sorted results.
         * @param {boolean} [sinceLastCampaign] Filter subscribers by those subscribed/unsubscribed/pending/cleaned since last email campaign send. Member status is required to use this filter.
         * @param {string} [unsubscribedSince] Filter subscribers by those unsubscribed since a specific date. Using any status other than unsubscribed with this filter will result in an error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersInfo: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, emailType?: string, status?: 'subscribed' | 'unsubscribed' | 'cleaned' | 'pending' | 'transactional' | 'archived', sinceTimestampOpt?: string, beforeTimestampOpt?: string, sinceLastChanged?: string, beforeLastChanged?: string, uniqueEmailId?: string, vipOnly?: boolean, interestCategoryId?: string, interestIds?: string, interestMatch?: 'any' | 'all' | 'none', sortField?: 'timestamp_opt' | 'timestamp_signup' | 'last_changed', sortDir?: 'ASC' | 'DESC', sinceLastCampaign?: boolean, unsubscribedSince?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMembersInfo', 'listId', listId)
            const localVarPath = `/lists/{list_id}/members`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (emailType !== undefined) {
                localVarQueryParameter['email_type'] = emailType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sinceTimestampOpt !== undefined) {
                localVarQueryParameter['since_timestamp_opt'] = sinceTimestampOpt;
            }

            if (beforeTimestampOpt !== undefined) {
                localVarQueryParameter['before_timestamp_opt'] = beforeTimestampOpt;
            }

            if (sinceLastChanged !== undefined) {
                localVarQueryParameter['since_last_changed'] = sinceLastChanged;
            }

            if (beforeLastChanged !== undefined) {
                localVarQueryParameter['before_last_changed'] = beforeLastChanged;
            }

            if (uniqueEmailId !== undefined) {
                localVarQueryParameter['unique_email_id'] = uniqueEmailId;
            }

            if (vipOnly !== undefined) {
                localVarQueryParameter['vip_only'] = vipOnly;
            }

            if (interestCategoryId !== undefined) {
                localVarQueryParameter['interest_category_id'] = interestCategoryId;
            }

            if (interestIds !== undefined) {
                localVarQueryParameter['interest_ids'] = interestIds;
            }

            if (interestMatch !== undefined) {
                localVarQueryParameter['interest_match'] = interestMatch;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sort_field'] = sortField;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (sinceLastCampaign !== undefined) {
                localVarQueryParameter['since_last_campaign'] = sinceLastCampaign;
            }

            if (unsubscribedSince !== undefined) {
                localVarQueryParameter['unsubscribed_since'] = unsubscribedSince;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific merge field.
         * @summary Get merge field
         * @param {string} listId The unique ID for the list.
         * @param {string} mergeId The id for the merge field.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeFieldInfo: async (listId: string, mergeId: string, excludeFields?: Array<string>, fields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getMergeFieldInfo', 'listId', listId)
            // verify required parameter 'mergeId' is not null or undefined
            assertParamExists('getMergeFieldInfo', 'mergeId', mergeId)
            const localVarPath = `/lists/{list_id}/merge-fields/{merge_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"merge_id"}}`, encodeURIComponent(String(mergeId !== undefined ? mergeId : `-merge_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/merge-fields/{merge_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.
         * @summary List recent activity
         * @param {string} listId The unique ID for the list.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivityStats: async (listId: string, count?: number, offset?: number, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getRecentActivityStats', 'listId', listId)
            const localVarPath = `/lists/{list_id}/activity`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/activity',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific segment.
         * @summary Get segment info
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {boolean} [includeCleaned] Include cleaned members in response
         * @param {boolean} [includeTransactional] Include transactional members in response
         * @param {boolean} [includeUnsubscribed] Include unsubscribed members in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentInfo: async (listId: string, segmentId: string, fields?: Array<string>, excludeFields?: Array<string>, includeCleaned?: boolean, includeTransactional?: boolean, includeUnsubscribed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSegmentInfo', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegmentInfo', 'segmentId', segmentId)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (includeCleaned !== undefined) {
                localVarQueryParameter['include_cleaned'] = includeCleaned;
            }

            if (includeTransactional !== undefined) {
                localVarQueryParameter['include_transactional'] = includeTransactional;
            }

            if (includeUnsubscribed !== undefined) {
                localVarQueryParameter['include_unsubscribed'] = includeUnsubscribed;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about members in a saved segment.
         * @summary List members in segment
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {boolean} [includeCleaned] Include cleaned members in response
         * @param {boolean} [includeTransactional] Include transactional members in response
         * @param {boolean} [includeUnsubscribed] Include unsubscribed members in response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembers: async (listId: string, segmentId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, includeCleaned?: boolean, includeTransactional?: boolean, includeUnsubscribed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSegmentMembers', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegmentMembers', 'segmentId', segmentId)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}/members`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (includeCleaned !== undefined) {
                localVarQueryParameter['include_cleaned'] = includeCleaned;
            }

            if (includeTransactional !== undefined) {
                localVarQueryParameter['include_transactional'] = includeTransactional;
            }

            if (includeUnsubscribed !== undefined) {
                localVarQueryParameter['include_unsubscribed'] = includeUnsubscribed;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}/members',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all available segments for a specific list.
         * @summary List segments
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [type] Limit results based on segment type.
         * @param {string} [sinceCreatedAt] Restrict results to segments created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeCreatedAt] Restrict results to segments created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {boolean} [includeCleaned] Include cleaned members in response
         * @param {boolean} [includeTransactional] Include transactional members in response
         * @param {boolean} [includeUnsubscribed] Include unsubscribed members in response
         * @param {string} [sinceUpdatedAt] Restrict results to segments update after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeUpdatedAt] Restrict results to segments update before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentsInfo: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, type?: string, sinceCreatedAt?: string, beforeCreatedAt?: string, includeCleaned?: boolean, includeTransactional?: boolean, includeUnsubscribed?: boolean, sinceUpdatedAt?: string, beforeUpdatedAt?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSegmentsInfo', 'listId', listId)
            const localVarPath = `/lists/{list_id}/segments`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sinceCreatedAt !== undefined) {
                localVarQueryParameter['since_created_at'] = sinceCreatedAt;
            }

            if (beforeCreatedAt !== undefined) {
                localVarQueryParameter['before_created_at'] = beforeCreatedAt;
            }

            if (includeCleaned !== undefined) {
                localVarQueryParameter['include_cleaned'] = includeCleaned;
            }

            if (includeTransactional !== undefined) {
                localVarQueryParameter['include_transactional'] = includeTransactional;
            }

            if (includeUnsubscribed !== undefined) {
                localVarQueryParameter['include_unsubscribed'] = includeUnsubscribed;
            }

            if (sinceUpdatedAt !== undefined) {
                localVarQueryParameter['since_updated_at'] = sinceUpdatedAt;
            }

            if (beforeUpdatedAt !== undefined) {
                localVarQueryParameter['before_updated_at'] = beforeUpdatedAt;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get signup forms for a specific list.
         * @summary List signup forms
         * @param {string} listId The unique ID for the list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignupForms: async (listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSignupForms', 'listId', listId)
            const localVarPath = `/lists/{list_id}/signup-forms`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/signup-forms',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a specific survey.
         * @summary Get survey
         * @param {string} listId The unique ID for the list.
         * @param {string} surveyId The ID of the survey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurveyDetails: async (listId: string, surveyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSurveyDetails', 'listId', listId)
            // verify required parameter 'surveyId' is not null or undefined
            assertParamExists('getSurveyDetails', 'surveyId', surveyId)
            const localVarPath = `/lists/{list_id}/surveys/{survey_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"survey_id"}}`, encodeURIComponent(String(surveyId !== undefined ? surveyId : `-survey_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/surveys/{survey_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all available surveys for a specific list.
         * @summary Get information about all surveys for a list
         * @param {string} listId The unique ID for the list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurveysInfo: async (listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getSurveysInfo', 'listId', listId)
            const localVarPath = `/lists/{list_id}/surveys`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/surveys',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific webhook.
         * @summary Get webhook info
         * @param {string} listId The unique ID for the list.
         * @param {string} webhookId The webhook\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookInfo: async (listId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getWebhookInfo', 'listId', listId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhookInfo', 'webhookId', webhookId)
            const localVarPath = `/lists/{list_id}/webhooks/{webhook_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId !== undefined ? webhookId : `-webhook_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/webhooks/{webhook_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all webhooks for a specific list.
         * @summary List webhooks
         * @param {string} listId The unique ID for the list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksInfo: async (listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getWebhooksInfo', 'listId', listId)
            const localVarPath = `/lists/{list_id}/webhooks`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/webhooks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of this category\'s interests.
         * @summary List interests in category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoryInterests: async (listId: string, interestCategoryId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listCategoryInterests', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('listCategoryInterests', 'interestCategoryId', interestCategoryId)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}/interests`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}/interests',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a list\'s interest categories.
         * @summary List interest categories
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [type] Restrict results a type of interest group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterestCategories: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listInterestCategories', 'listId', listId)
            const localVarPath = `/lists/{list_id}/interest-categories`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all merge fields for an audience.
         * @summary List merge fields
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [type] The merge field type.
         * @param {boolean} [required] Whether it\&#39;s a required merge field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMergeFields: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, type?: string, required?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listMergeFields', 'listId', listId)
            const localVarPath = `/lists/{list_id}/merge-fields`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (required !== undefined) {
                localVarQueryParameter['required'] = required;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/merge-fields',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the top email clients based on user-agent strings.
         * @summary List top email clients
         * @param {string} listId The unique ID for the list.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEmailClients: async (listId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listTopEmailClients', 'listId', listId)
            const localVarPath = `/lists/{list_id}/clients`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/clients',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a member from the specified static segment.
         * @summary Remove list member from segment
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberFromSegment: async (listId: string, segmentId: string, subscriberHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('removeMemberFromSegment', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('removeMemberFromSegment', 'segmentId', segmentId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('removeMemberFromSegment', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}/members/{subscriber_hash}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}/members/{subscriber_hash}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.
         * @summary Delete list member
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberPermanent: async (listId: string, subscriberHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('removeMemberPermanent', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('removeMemberPermanent', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/actions/delete-permanent`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/actions/delete-permanent',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for tags on a list by name. If no name is provided, will return all tags on the list.
         * @summary Search for tags on a list by name.
         * @param {string} listId The unique ID for the list.
         * @param {string} [name] The search query used to filter tags.  The search query will be compared to each tag as a prefix, so all tags that have a name starting with this field will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTagsByName: async (listId: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('searchTagsByName', 'listId', listId)
            const localVarPath = `/lists/{list_id}/tag-search`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/tag-search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific interest category.
         * @summary Update interest category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {ListsAddInterestCategoryRequest} listsAddInterestCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterestCategory: async (listId: string, interestCategoryId: string, listsAddInterestCategoryRequest: ListsAddInterestCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateInterestCategory', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('updateInterestCategory', 'interestCategoryId', interestCategoryId)
            // verify required parameter 'listsAddInterestCategoryRequest' is not null or undefined
            assertParamExists('updateInterestCategory', 'listsAddInterestCategoryRequest', listsAddInterestCategoryRequest)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddInterestCategoryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddInterestCategoryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update interests or \'group names\' for a specific category.
         * @summary Update interest in category
         * @param {string} listId The unique ID for the list.
         * @param {string} interestCategoryId The unique ID for the interest category.
         * @param {string} interestId The specific interest or \&#39;group name\&#39;.
         * @param {ListsAddInterestInCategoryRequest} listsAddInterestInCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterestCategoryInterest: async (listId: string, interestCategoryId: string, interestId: string, listsAddInterestInCategoryRequest: ListsAddInterestInCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateInterestCategoryInterest', 'listId', listId)
            // verify required parameter 'interestCategoryId' is not null or undefined
            assertParamExists('updateInterestCategoryInterest', 'interestCategoryId', interestCategoryId)
            // verify required parameter 'interestId' is not null or undefined
            assertParamExists('updateInterestCategoryInterest', 'interestId', interestId)
            // verify required parameter 'listsAddInterestInCategoryRequest' is not null or undefined
            assertParamExists('updateInterestCategoryInterest', 'listsAddInterestInCategoryRequest', listsAddInterestInCategoryRequest)
            const localVarPath = `/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"interest_category_id"}}`, encodeURIComponent(String(interestCategoryId !== undefined ? interestCategoryId : `-interest_category_id-`)))
                .replace(`{${"interest_id"}}`, encodeURIComponent(String(interestId !== undefined ? interestId : `-interest_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddInterestInCategoryRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddInterestInCategoryRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific list member.
         * @summary Update list member
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {ListsUpdateMemberRequest} listsUpdateMemberRequest 
         * @param {boolean} [skipMergeValidation] If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember: async (listId: string, subscriberHash: string, listsUpdateMemberRequest: ListsUpdateMemberRequest, skipMergeValidation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateMember', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('updateMember', 'subscriberHash', subscriberHash)
            // verify required parameter 'listsUpdateMemberRequest' is not null or undefined
            assertParamExists('updateMember', 'listsUpdateMemberRequest', listsUpdateMemberRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (skipMergeValidation !== undefined) {
                localVarQueryParameter['skip_merge_validation'] = skipMergeValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsUpdateMemberRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsUpdateMemberRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific merge field.
         * @summary Update merge field
         * @param {string} listId The unique ID for the list.
         * @param {string} mergeId The id for the merge field.
         * @param {ListsUpdateMergeFieldRequest} listsUpdateMergeFieldRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMergeField: async (listId: string, mergeId: string, listsUpdateMergeFieldRequest: ListsUpdateMergeFieldRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateMergeField', 'listId', listId)
            // verify required parameter 'mergeId' is not null or undefined
            assertParamExists('updateMergeField', 'mergeId', mergeId)
            // verify required parameter 'listsUpdateMergeFieldRequest' is not null or undefined
            assertParamExists('updateMergeField', 'listsUpdateMergeFieldRequest', listsUpdateMergeFieldRequest)
            const localVarPath = `/lists/{list_id}/merge-fields/{merge_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"merge_id"}}`, encodeURIComponent(String(mergeId !== undefined ? mergeId : `-merge_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsUpdateMergeFieldRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/merge-fields/{merge_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsUpdateMergeFieldRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific note for a specific list member.
         * @summary Update note
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {string} noteId The id for the note.
         * @param {ListsAddMemberNoteRequest} listsAddMemberNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNoteSpecificListMember: async (listId: string, subscriberHash: string, noteId: string, listsAddMemberNoteRequest: ListsAddMemberNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateNoteSpecificListMember', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('updateNoteSpecificListMember', 'subscriberHash', subscriberHash)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('updateNoteSpecificListMember', 'noteId', noteId)
            // verify required parameter 'listsAddMemberNoteRequest' is not null or undefined
            assertParamExists('updateNoteSpecificListMember', 'listsAddMemberNoteRequest', listsAddMemberNoteRequest)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId !== undefined ? noteId : `-note_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsAddMemberNoteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsAddMemberNoteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific segment in a list.
         * @summary Update segment
         * @param {string} listId The unique ID for the list.
         * @param {string} segmentId The unique id for the segment.
         * @param {ListsUpdateSegmentByIdRequest} listsUpdateSegmentByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentById: async (listId: string, segmentId: string, listsUpdateSegmentByIdRequest: ListsUpdateSegmentByIdRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateSegmentById', 'listId', listId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('updateSegmentById', 'segmentId', segmentId)
            // verify required parameter 'listsUpdateSegmentByIdRequest' is not null or undefined
            assertParamExists('updateSegmentById', 'listsUpdateSegmentByIdRequest', listsUpdateSegmentByIdRequest)
            const localVarPath = `/lists/{list_id}/segments/{segment_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId !== undefined ? segmentId : `-segment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsUpdateSegmentByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/segments/{segment_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsUpdateSegmentByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the settings for a specific list.
         * @summary Update lists
         * @param {string} listId The unique ID for the list.
         * @param {ListsUpdateSettingsRequest} listsUpdateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: async (listId: string, listsUpdateSettingsRequest: ListsUpdateSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateSettings', 'listId', listId)
            // verify required parameter 'listsUpdateSettingsRequest' is not null or undefined
            assertParamExists('updateSettings', 'listsUpdateSettingsRequest', listsUpdateSettingsRequest)
            const localVarPath = `/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsUpdateSettingsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsUpdateSettingsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the settings for an existing webhook.
         * @summary Update webhook
         * @param {string} listId The unique ID for the list.
         * @param {string} webhookId The webhook\&#39;s id.
         * @param {ListsCreateWebhookRequest} listsCreateWebhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookSettings: async (listId: string, webhookId: string, listsCreateWebhookRequest: ListsCreateWebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateWebhookSettings', 'listId', listId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhookSettings', 'webhookId', webhookId)
            // verify required parameter 'listsCreateWebhookRequest' is not null or undefined
            assertParamExists('updateWebhookSettings', 'listsCreateWebhookRequest', listsCreateWebhookRequest)
            const localVarPath = `/lists/{list_id}/webhooks/{webhook_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId !== undefined ? webhookId : `-webhook_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: listsCreateWebhookRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/webhooks/{webhook_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(listsCreateWebhookRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {Array<string>} [activityFilters] A comma-separated list of activity filters that correspond to a set of activity types, e.g \&quot;?activity_filters&#x3D;open,bounce,click\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRecentActivity: async (listId: string, subscriberHash: string, fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, activityFilters?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('viewRecentActivity', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('viewRecentActivity', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/activity-feed`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (activityFilters) {
                localVarQueryParameter['activity_filters'] = activityFilters.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/activity-feed',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the last 50 events of a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity 50
         * @param {string} listId The unique ID for the list.
         * @param {string} subscriberHash The MD5 hash of the lowercase version of the list member\&#39;s email address. This endpoint also accepts a list member\&#39;s email address or contact_id.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [action] A comma seperated list of actions to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRecentActivityEvents: async (listId: string, subscriberHash: string, fields?: Array<string>, excludeFields?: Array<string>, action?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('viewRecentActivityEvents', 'listId', listId)
            // verify required parameter 'subscriberHash' is not null or undefined
            assertParamExists('viewRecentActivityEvents', 'subscriberHash', subscriberHash)
            const localVarPath = `/lists/{list_id}/members/{subscriber_hash}/activity`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId !== undefined ? listId : `-list_id-`)))
                .replace(`{${"subscriber_hash"}}`, encodeURIComponent(String(subscriberHash !== undefined ? subscriberHash : `-subscriber_hash-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (action) {
                localVarQueryParameter['action'] = action.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/lists/{list_id}/members/{subscriber_hash}/activity',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListsApi - functional programming interface
 * @export
 */
export const ListsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new interest category.
         * @summary Add interest category
         * @param {ListsApiAddInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addInterestCategory(requestParameters: ListsApiAddInterestCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddInterestCategoryResponse>> {
            const listsAddInterestCategoryRequest: ListsAddInterestCategoryRequest = {
                title: requestParameters.title,
                display_order: requestParameters.display_order,
                type: requestParameters.type
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addInterestCategory(requestParameters.listId, listsAddInterestCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new interest or \'group name\' for a specific category.
         * @summary Add interest in category
         * @param {ListsApiAddInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addInterestInCategory(requestParameters: ListsApiAddInterestInCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddInterestInCategoryResponse>> {
            const listsAddInterestInCategoryRequest: ListsAddInterestInCategoryRequest = {
                name: requestParameters.name,
                display_order: requestParameters.display_order
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addInterestInCategory(requestParameters.listId, requestParameters.interestCategoryId, listsAddInterestInCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an event for a list member.
         * @summary Add event
         * @param {ListsApiAddMemberEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberEvent(requestParameters: ListsApiAddMemberEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const listsAddMemberEventRequest: ListsAddMemberEventRequest = {
                name: requestParameters.name,
                properties: requestParameters.properties,
                is_syncing: requestParameters.is_syncing,
                occurred_at: requestParameters.occurred_at
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberEvent(requestParameters.listId, requestParameters.subscriberHash, listsAddMemberEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new note for a specific subscriber.
         * @summary Add member note
         * @param {ListsApiAddMemberNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberNote(requestParameters: ListsApiAddMemberNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddMemberNoteResponse>> {
            const listsAddMemberNoteRequest: ListsAddMemberNoteRequest = {
                note: requestParameters.note
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberNote(requestParameters.listId, requestParameters.subscriberHash, listsAddMemberNoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or remove tags from a list member. If a tag that does not exist is passed in and set as \'active\', a new tag will be created.
         * @summary Add or remove member tags
         * @param {ListsApiAddMemberTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberTags(requestParameters: ListsApiAddMemberTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const listsAddMemberTagsRequest: ListsAddMemberTagsRequest = {
                tags: requestParameters.tags,
                is_syncing: requestParameters.is_syncing
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberTags(requestParameters.listId, requestParameters.subscriberHash, listsAddMemberTagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new member to the list.
         * @summary Add member to list
         * @param {ListsApiAddMemberToListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberToList(requestParameters: ListsApiAddMemberToListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddMemberToListResponse>> {
            const listsAddMemberToListRequest: ListsAddMemberToListRequest = {
                tags: requestParameters.tags,
                email_address: requestParameters.email_address,
                email_type: requestParameters.email_type,
                status: requestParameters.status,
                merge_fields: requestParameters.merge_fields,
                interests: requestParameters.interests,
                language: requestParameters.language,
                vip: requestParameters.vip,
                location: requestParameters.location,
                marketing_permissions: requestParameters.marketing_permissions,
                ip_signup: requestParameters.ip_signup,
                timestamp_signup: requestParameters.timestamp_signup,
                ip_opt: requestParameters.ip_opt,
                timestamp_opt: requestParameters.timestamp_opt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberToList(requestParameters.listId, listsAddMemberToListRequest, requestParameters.skipMergeValidation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a member to a static segment.
         * @summary Add member to segment
         * @param {ListsApiAddMemberToSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberToSegment(requestParameters: ListsApiAddMemberToSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddMemberToSegmentResponse>> {
            const listsAddMemberToSegmentRequest: ListsAddMemberToSegmentRequest = {
                email_address: requestParameters.email_address
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberToSegment(requestParameters.listId, requestParameters.segmentId, listsAddMemberToSegmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new merge field for a specific audience.
         * @summary Add merge field
         * @param {ListsApiAddMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMergeField(requestParameters: ListsApiAddMergeFieldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddMergeFieldResponse>> {
            const listsAddMergeFieldRequest: ListsAddMergeFieldRequest = {
                tag: requestParameters.tag,
                name: requestParameters.name,
                type: requestParameters.type,
                required: requestParameters.required,
                default_value: requestParameters.default_value,
                public: requestParameters.public,
                display_order: requestParameters.display_order,
                options: requestParameters.options,
                help_text: requestParameters.help_text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMergeField(requestParameters.listId, listsAddMergeFieldRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new segment in a specific list.
         * @summary Add segment
         * @param {ListsApiAddNewSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewSegment(requestParameters: ListsApiAddNewSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddNewSegmentResponse>> {
            const listsAddNewSegmentRequest: ListsAddNewSegmentRequest = {
                name: requestParameters.name,
                static_segment: requestParameters.static_segment,
                options: requestParameters.options
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewSegment(requestParameters.listId, listsAddNewSegmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or update a list member.
         * @summary Add or update list member
         * @param {ListsApiAddOrUpdateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateMember(requestParameters: ListsApiAddOrUpdateMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsAddOrUpdateMemberResponse>> {
            const listsAddOrUpdateMemberRequest: ListsAddOrUpdateMemberRequest = {
                email_address: requestParameters.email_address,
                status_if_new: requestParameters.status_if_new,
                email_type: requestParameters.email_type,
                status: requestParameters.status,
                merge_fields: requestParameters.merge_fields,
                interests: requestParameters.interests,
                language: requestParameters.language,
                vip: requestParameters.vip,
                location: requestParameters.location,
                marketing_permissions: requestParameters.marketing_permissions,
                ip_signup: requestParameters.ip_signup,
                timestamp_signup: requestParameters.timestamp_signup,
                ip_opt: requestParameters.ip_opt,
                timestamp_opt: requestParameters.timestamp_opt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateMember(requestParameters.listId, requestParameters.subscriberHash, listsAddOrUpdateMemberRequest, requestParameters.skipMergeValidation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archive a list member. To permanently delete, use the delete-permanent action.
         * @summary Archive list member
         * @param {ListsApiArchiveMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveMember(requestParameters: ListsApiArchiveMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveMember(requestParameters.listId, requestParameters.subscriberHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Batch add/remove list members to static segment
         * @summary Batch add or remove members
         * @param {ListsApiBatchAddRemoveMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchAddRemoveMembers(requestParameters: ListsApiBatchAddRemoveMembersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsBatchAddRemoveMembersResponse>> {
            const listsBatchAddRemoveMembersRequest: ListsBatchAddRemoveMembersRequest = {
                members_to_add: requestParameters.members_to_add,
                members_to_remove: requestParameters.members_to_remove
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchAddRemoveMembers(requestParameters.listId, requestParameters.segmentId, listsBatchAddRemoveMembersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Batch subscribe or unsubscribe list members.
         * @summary Batch subscribe or unsubscribe
         * @param {ListsApiBatchSubscribeOrUnsubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchSubscribeOrUnsubscribe(requestParameters: ListsApiBatchSubscribeOrUnsubscribeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsBatchSubscribeOrUnsubscribeResponse>> {
            const listsBatchSubscribeOrUnsubscribeRequest: ListsBatchSubscribeOrUnsubscribeRequest = {
                members: requestParameters.members,
                sync_tags: requestParameters.sync_tags,
                update_existing: requestParameters.update_existing
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchSubscribeOrUnsubscribe(requestParameters.listId, listsBatchSubscribeOrUnsubscribeRequest, requestParameters.skipMergeValidation, requestParameters.skipDuplicateCheck, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new list in your Mailchimp account.
         * @summary Add list
         * @param {ListsApiCreateNewListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewList(requestParameters: ListsApiCreateNewListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsCreateNewListResponse>> {
            const listsCreateNewListRequest: ListsCreateNewListRequest = {
                name: requestParameters.name,
                contact: requestParameters.contact,
                permission_reminder: requestParameters.permission_reminder,
                use_archive_bar: requestParameters.use_archive_bar,
                campaign_defaults: requestParameters.campaign_defaults,
                notify_on_subscribe: requestParameters.notify_on_subscribe,
                notify_on_unsubscribe: requestParameters.notify_on_unsubscribe,
                email_type_option: requestParameters.email_type_option,
                double_optin: requestParameters.double_optin,
                marketing_permissions: requestParameters.marketing_permissions
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewList(listsCreateNewListRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new webhook for a specific list.
         * @summary Add webhook
         * @param {ListsApiCreateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(requestParameters: ListsApiCreateWebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsCreateWebhookResponse>> {
            const listsCreateWebhookRequest: ListsCreateWebhookRequest = {
                url: requestParameters.url,
                events: requestParameters.events,
                sources: requestParameters.sources
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(requestParameters.listId, listsCreateWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Customize a list\'s default signup form.
         * @summary Customize signup form
         * @param {ListsApiCustomizeSignupFormRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customizeSignupForm(requestParameters: ListsApiCustomizeSignupFormRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsCustomizeSignupFormResponse>> {
            const listsCustomizeSignupFormRequest: ListsCustomizeSignupFormRequest = {
                header: requestParameters.header,
                contents: requestParameters.contents,
                styles: requestParameters.styles
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.customizeSignupForm(requestParameters.listId, listsCustomizeSignupFormRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific interest category.
         * @summary Delete interest category
         * @param {ListsApiDeleteInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInterestCategory(requestParameters: ListsApiDeleteInterestCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInterestCategory(requestParameters.listId, requestParameters.interestCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete interests or group names in a specific category.
         * @summary Delete interest in category
         * @param {ListsApiDeleteInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInterestInCategory(requestParameters: ListsApiDeleteInterestInCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInterestInCategory(requestParameters.listId, requestParameters.interestCategoryId, requestParameters.interestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a list from your Mailchimp account. If you delete a list, you\'ll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.
         * @summary Delete list
         * @param {ListsApiDeleteListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteList(requestParameters: ListsApiDeleteListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteList(requestParameters.listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific merge field.
         * @summary Delete merge field
         * @param {ListsApiDeleteMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMergeField(requestParameters: ListsApiDeleteMergeFieldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMergeField(requestParameters.listId, requestParameters.mergeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific note for a specific list member.
         * @summary Delete note
         * @param {ListsApiDeleteNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(requestParameters: ListsApiDeleteNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(requestParameters.listId, requestParameters.subscriberHash, requestParameters.noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific segment in a list.
         * @summary Delete segment
         * @param {ListsApiDeleteSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(requestParameters: ListsApiDeleteSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(requestParameters.listId, requestParameters.segmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific webhook in a list.
         * @summary Delete webhook
         * @param {ListsApiDeleteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(requestParameters: ListsApiDeleteWebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(requestParameters.listId, requestParameters.webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about a specific abuse report.
         * @summary Get abuse report
         * @param {ListsApiGetAbuseReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbuseReport(requestParameters: ListsApiGetAbuseReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetAbuseReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbuseReport(requestParameters.listId, requestParameters.reportId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all abuse reports for a specific list.
         * @summary List abuse reports
         * @param {ListsApiGetAllAbuseReportsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAbuseReports(requestParameters: ListsApiGetAllAbuseReportsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetAllAbuseReportsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAbuseReports(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all lists in the account.
         * @summary Get lists info
         * @param {ListsApiGetAllInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInfo(requestParameters: ListsApiGetAllInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetAllInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInfo(requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.beforeDateCreated, requestParameters.sinceDateCreated, requestParameters.beforeCampaignLastSent, requestParameters.sinceCampaignLastSent, requestParameters.email, requestParameters.sortField, requestParameters.sortDir, requestParameters.hasEcommerceStore, requestParameters.includeTotalContacts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a summary of a specific list\'s growth activity for a specific month and year.
         * @summary Get growth history by month
         * @param {ListsApiGetGrowthHistoryByMonthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrowthHistoryByMonth(requestParameters: ListsApiGetGrowthHistoryByMonthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetGrowthHistoryByMonthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrowthHistoryByMonth(requestParameters.listId, requestParameters.month, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a month-by-month summary of a specific list\'s growth activity.
         * @summary List growth history data
         * @param {ListsApiGetGrowthHistoryDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrowthHistoryData(requestParameters: ListsApiGetGrowthHistoryDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetGrowthHistoryDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrowthHistoryData(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.sortField, requestParameters.sortDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific interest category.
         * @summary Get interest category info
         * @param {ListsApiGetInterestCategoryInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterestCategoryInfo(requestParameters: ListsApiGetInterestCategoryInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetInterestCategoryInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterestCategoryInfo(requestParameters.listId, requestParameters.interestCategoryId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get interests or \'group names\' for a specific category.
         * @summary Get interest in category
         * @param {ListsApiGetInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterestInCategory(requestParameters: ListsApiGetInterestInCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetInterestInCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterestInCategory(requestParameters.listId, requestParameters.interestCategoryId, requestParameters.interestId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven\'t confirmed their subscription yet and unsubscribed or cleaned.
         * @summary Get list info
         * @param {ListsApiGetListInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListInfo(requestParameters: ListsApiGetListInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetListInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListInfo(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.includeTotalContacts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the locations (countries) that the list\'s subscribers have been tagged to based on geocoding their IP address.
         * @summary List locations
         * @param {ListsApiGetLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocations(requestParameters: ListsApiGetLocationsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetLocationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocations(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get events for a contact.
         * @summary List member events
         * @param {ListsApiGetMemberEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberEvents(requestParameters: ListsApiGetMemberEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberEvents(requestParameters.listId, requestParameters.subscriberHash, requestParameters.count, requestParameters.offset, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the last 50 Goal events for a member on a specific list.
         * @summary List member goal events
         * @param {ListsApiGetMemberGoalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberGoals(requestParameters: ListsApiGetMemberGoalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberGoalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberGoals(requestParameters.listId, requestParameters.subscriberHash, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.
         * @summary Get member info
         * @param {ListsApiGetMemberInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberInfo(requestParameters: ListsApiGetMemberInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberInfo(requestParameters.listId, requestParameters.subscriberHash, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific note for a specific list member.
         * @summary Get member note
         * @param {ListsApiGetMemberNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberNote(requestParameters: ListsApiGetMemberNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberNote(requestParameters.listId, requestParameters.subscriberHash, requestParameters.noteId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recent notes for a specific list member.
         * @summary List recent member notes
         * @param {ListsApiGetMemberNotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberNotes(requestParameters: ListsApiGetMemberNotesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberNotesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberNotes(requestParameters.listId, requestParameters.subscriberHash, requestParameters.sortField, requestParameters.sortDir, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the tags on a list member.
         * @summary List member tags
         * @param {ListsApiGetMemberTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberTags(requestParameters: ListsApiGetMemberTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMemberTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberTags(requestParameters.listId, requestParameters.subscriberHash, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about members in a specific Mailchimp list.
         * @summary List members info
         * @param {ListsApiGetMembersInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersInfo(requestParameters: ListsApiGetMembersInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMembersInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembersInfo(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.emailType, requestParameters.status, requestParameters.sinceTimestampOpt, requestParameters.beforeTimestampOpt, requestParameters.sinceLastChanged, requestParameters.beforeLastChanged, requestParameters.uniqueEmailId, requestParameters.vipOnly, requestParameters.interestCategoryId, requestParameters.interestIds, requestParameters.interestMatch, requestParameters.sortField, requestParameters.sortDir, requestParameters.sinceLastCampaign, requestParameters.unsubscribedSince, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific merge field.
         * @summary Get merge field
         * @param {ListsApiGetMergeFieldInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMergeFieldInfo(requestParameters: ListsApiGetMergeFieldInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetMergeFieldInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMergeFieldInfo(requestParameters.listId, requestParameters.mergeId, requestParameters.excludeFields, requestParameters.fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.
         * @summary List recent activity
         * @param {ListsApiGetRecentActivityStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentActivityStats(requestParameters: ListsApiGetRecentActivityStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetRecentActivityStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentActivityStats(requestParameters.listId, requestParameters.count, requestParameters.offset, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific segment.
         * @summary Get segment info
         * @param {ListsApiGetSegmentInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentInfo(requestParameters: ListsApiGetSegmentInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetSegmentInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentInfo(requestParameters.listId, requestParameters.segmentId, requestParameters.fields, requestParameters.excludeFields, requestParameters.includeCleaned, requestParameters.includeTransactional, requestParameters.includeUnsubscribed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about members in a saved segment.
         * @summary List members in segment
         * @param {ListsApiGetSegmentMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentMembers(requestParameters: ListsApiGetSegmentMembersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetSegmentMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentMembers(requestParameters.listId, requestParameters.segmentId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.includeCleaned, requestParameters.includeTransactional, requestParameters.includeUnsubscribed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all available segments for a specific list.
         * @summary List segments
         * @param {ListsApiGetSegmentsInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentsInfo(requestParameters: ListsApiGetSegmentsInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetSegmentsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentsInfo(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.type, requestParameters.sinceCreatedAt, requestParameters.beforeCreatedAt, requestParameters.includeCleaned, requestParameters.includeTransactional, requestParameters.includeUnsubscribed, requestParameters.sinceUpdatedAt, requestParameters.beforeUpdatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get signup forms for a specific list.
         * @summary List signup forms
         * @param {ListsApiGetSignupFormsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignupForms(requestParameters: ListsApiGetSignupFormsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetSignupFormsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignupForms(requestParameters.listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about a specific survey.
         * @summary Get survey
         * @param {ListsApiGetSurveyDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSurveyDetails(requestParameters: ListsApiGetSurveyDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSurveyDetails(requestParameters.listId, requestParameters.surveyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all available surveys for a specific list.
         * @summary Get information about all surveys for a list
         * @param {ListsApiGetSurveysInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSurveysInfo(requestParameters: ListsApiGetSurveysInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSurveysInfo(requestParameters.listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific webhook.
         * @summary Get webhook info
         * @param {ListsApiGetWebhookInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookInfo(requestParameters: ListsApiGetWebhookInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetWebhookInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookInfo(requestParameters.listId, requestParameters.webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about all webhooks for a specific list.
         * @summary List webhooks
         * @param {ListsApiGetWebhooksInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksInfo(requestParameters: ListsApiGetWebhooksInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsGetWebhooksInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksInfo(requestParameters.listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of this category\'s interests.
         * @summary List interests in category
         * @param {ListsApiListCategoryInterestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategoryInterests(requestParameters: ListsApiListCategoryInterestsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsListCategoryInterestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategoryInterests(requestParameters.listId, requestParameters.interestCategoryId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a list\'s interest categories.
         * @summary List interest categories
         * @param {ListsApiListInterestCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInterestCategories(requestParameters: ListsApiListInterestCategoriesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsListInterestCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInterestCategories(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all merge fields for an audience.
         * @summary List merge fields
         * @param {ListsApiListMergeFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMergeFields(requestParameters: ListsApiListMergeFieldsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsListMergeFieldsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMergeFields(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.type, requestParameters.required, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of the top email clients based on user-agent strings.
         * @summary List top email clients
         * @param {ListsApiListTopEmailClientsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopEmailClients(requestParameters: ListsApiListTopEmailClientsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsListTopEmailClientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopEmailClients(requestParameters.listId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a member from the specified static segment.
         * @summary Remove list member from segment
         * @param {ListsApiRemoveMemberFromSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemberFromSegment(requestParameters: ListsApiRemoveMemberFromSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemberFromSegment(requestParameters.listId, requestParameters.segmentId, requestParameters.subscriberHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.
         * @summary Delete list member
         * @param {ListsApiRemoveMemberPermanentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemberPermanent(requestParameters: ListsApiRemoveMemberPermanentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemberPermanent(requestParameters.listId, requestParameters.subscriberHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for tags on a list by name. If no name is provided, will return all tags on the list.
         * @summary Search for tags on a list by name.
         * @param {ListsApiSearchTagsByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTagsByName(requestParameters: ListsApiSearchTagsByNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsSearchTagsByNameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTagsByName(requestParameters.listId, requestParameters.name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific interest category.
         * @summary Update interest category
         * @param {ListsApiUpdateInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInterestCategory(requestParameters: ListsApiUpdateInterestCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateInterestCategoryResponse>> {
            const listsAddInterestCategoryRequest: ListsAddInterestCategoryRequest = {
                title: requestParameters.title,
                display_order: requestParameters.display_order,
                type: requestParameters.type
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInterestCategory(requestParameters.listId, requestParameters.interestCategoryId, listsAddInterestCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update interests or \'group names\' for a specific category.
         * @summary Update interest in category
         * @param {ListsApiUpdateInterestCategoryInterestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInterestCategoryInterest(requestParameters: ListsApiUpdateInterestCategoryInterestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateInterestCategoryInterestResponse>> {
            const listsAddInterestInCategoryRequest: ListsAddInterestInCategoryRequest = {
                name: requestParameters.name,
                display_order: requestParameters.display_order
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInterestCategoryInterest(requestParameters.listId, requestParameters.interestCategoryId, requestParameters.interestId, listsAddInterestInCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information for a specific list member.
         * @summary Update list member
         * @param {ListsApiUpdateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMember(requestParameters: ListsApiUpdateMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateMemberResponse>> {
            const listsUpdateMemberRequest: ListsUpdateMemberRequest = {
                email_address: requestParameters.email_address,
                email_type: requestParameters.email_type,
                status: requestParameters.status,
                merge_fields: requestParameters.merge_fields,
                interests: requestParameters.interests,
                language: requestParameters.language,
                vip: requestParameters.vip,
                location: requestParameters.location,
                marketing_permissions: requestParameters.marketing_permissions,
                ip_signup: requestParameters.ip_signup,
                timestamp_signup: requestParameters.timestamp_signup,
                ip_opt: requestParameters.ip_opt,
                timestamp_opt: requestParameters.timestamp_opt
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMember(requestParameters.listId, requestParameters.subscriberHash, listsUpdateMemberRequest, requestParameters.skipMergeValidation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific merge field.
         * @summary Update merge field
         * @param {ListsApiUpdateMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMergeField(requestParameters: ListsApiUpdateMergeFieldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateMergeFieldResponse>> {
            const listsUpdateMergeFieldRequest: ListsUpdateMergeFieldRequest = {
                tag: requestParameters.tag,
                name: requestParameters.name,
                required: requestParameters.required,
                default_value: requestParameters.default_value,
                public: requestParameters.public,
                display_order: requestParameters.display_order,
                options: requestParameters.options,
                help_text: requestParameters.help_text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMergeField(requestParameters.listId, requestParameters.mergeId, listsUpdateMergeFieldRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific note for a specific list member.
         * @summary Update note
         * @param {ListsApiUpdateNoteSpecificListMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNoteSpecificListMember(requestParameters: ListsApiUpdateNoteSpecificListMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateNoteSpecificListMemberResponse>> {
            const listsAddMemberNoteRequest: ListsAddMemberNoteRequest = {
                note: requestParameters.note
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNoteSpecificListMember(requestParameters.listId, requestParameters.subscriberHash, requestParameters.noteId, listsAddMemberNoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific segment in a list.
         * @summary Update segment
         * @param {ListsApiUpdateSegmentByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegmentById(requestParameters: ListsApiUpdateSegmentByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateSegmentByIdResponse>> {
            const listsUpdateSegmentByIdRequest: ListsUpdateSegmentByIdRequest = {
                name: requestParameters.name,
                static_segment: requestParameters.static_segment,
                options: requestParameters.options
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSegmentById(requestParameters.listId, requestParameters.segmentId, listsUpdateSegmentByIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the settings for a specific list.
         * @summary Update lists
         * @param {ListsApiUpdateSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettings(requestParameters: ListsApiUpdateSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateSettingsResponse>> {
            const listsUpdateSettingsRequest: ListsUpdateSettingsRequest = {
                name: requestParameters.name,
                contact: requestParameters.contact,
                permission_reminder: requestParameters.permission_reminder,
                use_archive_bar: requestParameters.use_archive_bar,
                campaign_defaults: requestParameters.campaign_defaults,
                notify_on_subscribe: requestParameters.notify_on_subscribe,
                notify_on_unsubscribe: requestParameters.notify_on_unsubscribe,
                email_type_option: requestParameters.email_type_option,
                double_optin: requestParameters.double_optin,
                marketing_permissions: requestParameters.marketing_permissions
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettings(requestParameters.listId, listsUpdateSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the settings for an existing webhook.
         * @summary Update webhook
         * @param {ListsApiUpdateWebhookSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhookSettings(requestParameters: ListsApiUpdateWebhookSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsUpdateWebhookSettingsResponse>> {
            const listsCreateWebhookRequest: ListsCreateWebhookRequest = {
                url: requestParameters.url,
                events: requestParameters.events,
                sources: requestParameters.sources
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookSettings(requestParameters.listId, requestParameters.webhookId, listsCreateWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity
         * @param {ListsApiViewRecentActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRecentActivity(requestParameters: ListsApiViewRecentActivityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsViewRecentActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRecentActivity(requestParameters.listId, requestParameters.subscriberHash, requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.activityFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the last 50 events of a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity 50
         * @param {ListsApiViewRecentActivityEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewRecentActivityEvents(requestParameters: ListsApiViewRecentActivityEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListsViewRecentActivityEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewRecentActivityEvents(requestParameters.listId, requestParameters.subscriberHash, requestParameters.fields, requestParameters.excludeFields, requestParameters.action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListsApi - factory interface
 * @export
 */
export const ListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListsApiFp(configuration)
    return {
        /**
         * Create a new interest category.
         * @summary Add interest category
         * @param {ListsApiAddInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInterestCategory(requestParameters: ListsApiAddInterestCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddInterestCategoryResponse> {
            return localVarFp.addInterestCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new interest or \'group name\' for a specific category.
         * @summary Add interest in category
         * @param {ListsApiAddInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInterestInCategory(requestParameters: ListsApiAddInterestInCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddInterestInCategoryResponse> {
            return localVarFp.addInterestInCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an event for a list member.
         * @summary Add event
         * @param {ListsApiAddMemberEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberEvent(requestParameters: ListsApiAddMemberEventRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addMemberEvent(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new note for a specific subscriber.
         * @summary Add member note
         * @param {ListsApiAddMemberNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberNote(requestParameters: ListsApiAddMemberNoteRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddMemberNoteResponse> {
            return localVarFp.addMemberNote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove tags from a list member. If a tag that does not exist is passed in and set as \'active\', a new tag will be created.
         * @summary Add or remove member tags
         * @param {ListsApiAddMemberTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberTags(requestParameters: ListsApiAddMemberTagsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addMemberTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new member to the list.
         * @summary Add member to list
         * @param {ListsApiAddMemberToListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToList(requestParameters: ListsApiAddMemberToListRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddMemberToListResponse> {
            return localVarFp.addMemberToList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a member to a static segment.
         * @summary Add member to segment
         * @param {ListsApiAddMemberToSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToSegment(requestParameters: ListsApiAddMemberToSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddMemberToSegmentResponse> {
            return localVarFp.addMemberToSegment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new merge field for a specific audience.
         * @summary Add merge field
         * @param {ListsApiAddMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMergeField(requestParameters: ListsApiAddMergeFieldRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddMergeFieldResponse> {
            return localVarFp.addMergeField(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new segment in a specific list.
         * @summary Add segment
         * @param {ListsApiAddNewSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSegment(requestParameters: ListsApiAddNewSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddNewSegmentResponse> {
            return localVarFp.addNewSegment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or update a list member.
         * @summary Add or update list member
         * @param {ListsApiAddOrUpdateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateMember(requestParameters: ListsApiAddOrUpdateMemberRequest, options?: AxiosRequestConfig): AxiosPromise<ListsAddOrUpdateMemberResponse> {
            return localVarFp.addOrUpdateMember(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive a list member. To permanently delete, use the delete-permanent action.
         * @summary Archive list member
         * @param {ListsApiArchiveMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveMember(requestParameters: ListsApiArchiveMemberRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.archiveMember(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch add/remove list members to static segment
         * @summary Batch add or remove members
         * @param {ListsApiBatchAddRemoveMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAddRemoveMembers(requestParameters: ListsApiBatchAddRemoveMembersRequest, options?: AxiosRequestConfig): AxiosPromise<ListsBatchAddRemoveMembersResponse> {
            return localVarFp.batchAddRemoveMembers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch subscribe or unsubscribe list members.
         * @summary Batch subscribe or unsubscribe
         * @param {ListsApiBatchSubscribeOrUnsubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchSubscribeOrUnsubscribe(requestParameters: ListsApiBatchSubscribeOrUnsubscribeRequest, options?: AxiosRequestConfig): AxiosPromise<ListsBatchSubscribeOrUnsubscribeResponse> {
            return localVarFp.batchSubscribeOrUnsubscribe(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new list in your Mailchimp account.
         * @summary Add list
         * @param {ListsApiCreateNewListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewList(requestParameters: ListsApiCreateNewListRequest, options?: AxiosRequestConfig): AxiosPromise<ListsCreateNewListResponse> {
            return localVarFp.createNewList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new webhook for a specific list.
         * @summary Add webhook
         * @param {ListsApiCreateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(requestParameters: ListsApiCreateWebhookRequest, options?: AxiosRequestConfig): AxiosPromise<ListsCreateWebhookResponse> {
            return localVarFp.createWebhook(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Customize a list\'s default signup form.
         * @summary Customize signup form
         * @param {ListsApiCustomizeSignupFormRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customizeSignupForm(requestParameters: ListsApiCustomizeSignupFormRequest, options?: AxiosRequestConfig): AxiosPromise<ListsCustomizeSignupFormResponse> {
            return localVarFp.customizeSignupForm(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific interest category.
         * @summary Delete interest category
         * @param {ListsApiDeleteInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterestCategory(requestParameters: ListsApiDeleteInterestCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInterestCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete interests or group names in a specific category.
         * @summary Delete interest in category
         * @param {ListsApiDeleteInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInterestInCategory(requestParameters: ListsApiDeleteInterestInCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInterestInCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a list from your Mailchimp account. If you delete a list, you\'ll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.
         * @summary Delete list
         * @param {ListsApiDeleteListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteList(requestParameters: ListsApiDeleteListRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific merge field.
         * @summary Delete merge field
         * @param {ListsApiDeleteMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMergeField(requestParameters: ListsApiDeleteMergeFieldRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMergeField(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific note for a specific list member.
         * @summary Delete note
         * @param {ListsApiDeleteNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(requestParameters: ListsApiDeleteNoteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific segment in a list.
         * @summary Delete segment
         * @param {ListsApiDeleteSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(requestParameters: ListsApiDeleteSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSegment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific webhook in a list.
         * @summary Delete webhook
         * @param {ListsApiDeleteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(requestParameters: ListsApiDeleteWebhookRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about a specific abuse report.
         * @summary Get abuse report
         * @param {ListsApiGetAbuseReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbuseReport(requestParameters: ListsApiGetAbuseReportRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetAbuseReportResponse> {
            return localVarFp.getAbuseReport(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all abuse reports for a specific list.
         * @summary List abuse reports
         * @param {ListsApiGetAllAbuseReportsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAbuseReports(requestParameters: ListsApiGetAllAbuseReportsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetAllAbuseReportsResponse> {
            return localVarFp.getAllAbuseReports(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all lists in the account.
         * @summary Get lists info
         * @param {ListsApiGetAllInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInfo(requestParameters: ListsApiGetAllInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetAllInfoResponse> {
            return localVarFp.getAllInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a summary of a specific list\'s growth activity for a specific month and year.
         * @summary Get growth history by month
         * @param {ListsApiGetGrowthHistoryByMonthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrowthHistoryByMonth(requestParameters: ListsApiGetGrowthHistoryByMonthRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetGrowthHistoryByMonthResponse> {
            return localVarFp.getGrowthHistoryByMonth(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a month-by-month summary of a specific list\'s growth activity.
         * @summary List growth history data
         * @param {ListsApiGetGrowthHistoryDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrowthHistoryData(requestParameters: ListsApiGetGrowthHistoryDataRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetGrowthHistoryDataResponse> {
            return localVarFp.getGrowthHistoryData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific interest category.
         * @summary Get interest category info
         * @param {ListsApiGetInterestCategoryInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterestCategoryInfo(requestParameters: ListsApiGetInterestCategoryInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetInterestCategoryInfoResponse> {
            return localVarFp.getInterestCategoryInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get interests or \'group names\' for a specific category.
         * @summary Get interest in category
         * @param {ListsApiGetInterestInCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterestInCategory(requestParameters: ListsApiGetInterestInCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetInterestInCategoryResponse> {
            return localVarFp.getInterestInCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven\'t confirmed their subscription yet and unsubscribed or cleaned.
         * @summary Get list info
         * @param {ListsApiGetListInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListInfo(requestParameters: ListsApiGetListInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetListInfoResponse> {
            return localVarFp.getListInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the locations (countries) that the list\'s subscribers have been tagged to based on geocoding their IP address.
         * @summary List locations
         * @param {ListsApiGetLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations(requestParameters: ListsApiGetLocationsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetLocationsResponse> {
            return localVarFp.getLocations(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get events for a contact.
         * @summary List member events
         * @param {ListsApiGetMemberEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberEvents(requestParameters: ListsApiGetMemberEventsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberEventsResponse> {
            return localVarFp.getMemberEvents(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last 50 Goal events for a member on a specific list.
         * @summary List member goal events
         * @param {ListsApiGetMemberGoalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberGoals(requestParameters: ListsApiGetMemberGoalsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberGoalsResponse> {
            return localVarFp.getMemberGoals(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.
         * @summary Get member info
         * @param {ListsApiGetMemberInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInfo(requestParameters: ListsApiGetMemberInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberInfoResponse> {
            return localVarFp.getMemberInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific note for a specific list member.
         * @summary Get member note
         * @param {ListsApiGetMemberNoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberNote(requestParameters: ListsApiGetMemberNoteRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberNoteResponse> {
            return localVarFp.getMemberNote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent notes for a specific list member.
         * @summary List recent member notes
         * @param {ListsApiGetMemberNotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberNotes(requestParameters: ListsApiGetMemberNotesRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberNotesResponse> {
            return localVarFp.getMemberNotes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tags on a list member.
         * @summary List member tags
         * @param {ListsApiGetMemberTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberTags(requestParameters: ListsApiGetMemberTagsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMemberTagsResponse> {
            return localVarFp.getMemberTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about members in a specific Mailchimp list.
         * @summary List members info
         * @param {ListsApiGetMembersInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersInfo(requestParameters: ListsApiGetMembersInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMembersInfoResponse> {
            return localVarFp.getMembersInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific merge field.
         * @summary Get merge field
         * @param {ListsApiGetMergeFieldInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeFieldInfo(requestParameters: ListsApiGetMergeFieldInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetMergeFieldInfoResponse> {
            return localVarFp.getMergeFieldInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.
         * @summary List recent activity
         * @param {ListsApiGetRecentActivityStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivityStats(requestParameters: ListsApiGetRecentActivityStatsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetRecentActivityStatsResponse> {
            return localVarFp.getRecentActivityStats(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific segment.
         * @summary Get segment info
         * @param {ListsApiGetSegmentInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentInfo(requestParameters: ListsApiGetSegmentInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetSegmentInfoResponse> {
            return localVarFp.getSegmentInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about members in a saved segment.
         * @summary List members in segment
         * @param {ListsApiGetSegmentMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembers(requestParameters: ListsApiGetSegmentMembersRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetSegmentMembersResponse> {
            return localVarFp.getSegmentMembers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all available segments for a specific list.
         * @summary List segments
         * @param {ListsApiGetSegmentsInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentsInfo(requestParameters: ListsApiGetSegmentsInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetSegmentsInfoResponse> {
            return localVarFp.getSegmentsInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get signup forms for a specific list.
         * @summary List signup forms
         * @param {ListsApiGetSignupFormsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignupForms(requestParameters: ListsApiGetSignupFormsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetSignupFormsResponse> {
            return localVarFp.getSignupForms(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about a specific survey.
         * @summary Get survey
         * @param {ListsApiGetSurveyDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurveyDetails(requestParameters: ListsApiGetSurveyDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSurveyDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all available surveys for a specific list.
         * @summary Get information about all surveys for a list
         * @param {ListsApiGetSurveysInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSurveysInfo(requestParameters: ListsApiGetSurveysInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSurveysInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific webhook.
         * @summary Get webhook info
         * @param {ListsApiGetWebhookInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookInfo(requestParameters: ListsApiGetWebhookInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetWebhookInfoResponse> {
            return localVarFp.getWebhookInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about all webhooks for a specific list.
         * @summary List webhooks
         * @param {ListsApiGetWebhooksInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksInfo(requestParameters: ListsApiGetWebhooksInfoRequest, options?: AxiosRequestConfig): AxiosPromise<ListsGetWebhooksInfoResponse> {
            return localVarFp.getWebhooksInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of this category\'s interests.
         * @summary List interests in category
         * @param {ListsApiListCategoryInterestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoryInterests(requestParameters: ListsApiListCategoryInterestsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsListCategoryInterestsResponse> {
            return localVarFp.listCategoryInterests(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a list\'s interest categories.
         * @summary List interest categories
         * @param {ListsApiListInterestCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInterestCategories(requestParameters: ListsApiListInterestCategoriesRequest, options?: AxiosRequestConfig): AxiosPromise<ListsListInterestCategoriesResponse> {
            return localVarFp.listInterestCategories(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all merge fields for an audience.
         * @summary List merge fields
         * @param {ListsApiListMergeFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMergeFields(requestParameters: ListsApiListMergeFieldsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsListMergeFieldsResponse> {
            return localVarFp.listMergeFields(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the top email clients based on user-agent strings.
         * @summary List top email clients
         * @param {ListsApiListTopEmailClientsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopEmailClients(requestParameters: ListsApiListTopEmailClientsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsListTopEmailClientsResponse> {
            return localVarFp.listTopEmailClients(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a member from the specified static segment.
         * @summary Remove list member from segment
         * @param {ListsApiRemoveMemberFromSegmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberFromSegment(requestParameters: ListsApiRemoveMemberFromSegmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeMemberFromSegment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.
         * @summary Delete list member
         * @param {ListsApiRemoveMemberPermanentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberPermanent(requestParameters: ListsApiRemoveMemberPermanentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeMemberPermanent(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for tags on a list by name. If no name is provided, will return all tags on the list.
         * @summary Search for tags on a list by name.
         * @param {ListsApiSearchTagsByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTagsByName(requestParameters: ListsApiSearchTagsByNameRequest, options?: AxiosRequestConfig): AxiosPromise<ListsSearchTagsByNameResponse> {
            return localVarFp.searchTagsByName(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific interest category.
         * @summary Update interest category
         * @param {ListsApiUpdateInterestCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterestCategory(requestParameters: ListsApiUpdateInterestCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateInterestCategoryResponse> {
            return localVarFp.updateInterestCategory(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update interests or \'group names\' for a specific category.
         * @summary Update interest in category
         * @param {ListsApiUpdateInterestCategoryInterestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInterestCategoryInterest(requestParameters: ListsApiUpdateInterestCategoryInterestRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateInterestCategoryInterestResponse> {
            return localVarFp.updateInterestCategoryInterest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific list member.
         * @summary Update list member
         * @param {ListsApiUpdateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(requestParameters: ListsApiUpdateMemberRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateMemberResponse> {
            return localVarFp.updateMember(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific merge field.
         * @summary Update merge field
         * @param {ListsApiUpdateMergeFieldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMergeField(requestParameters: ListsApiUpdateMergeFieldRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateMergeFieldResponse> {
            return localVarFp.updateMergeField(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific note for a specific list member.
         * @summary Update note
         * @param {ListsApiUpdateNoteSpecificListMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNoteSpecificListMember(requestParameters: ListsApiUpdateNoteSpecificListMemberRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateNoteSpecificListMemberResponse> {
            return localVarFp.updateNoteSpecificListMember(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific segment in a list.
         * @summary Update segment
         * @param {ListsApiUpdateSegmentByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentById(requestParameters: ListsApiUpdateSegmentByIdRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateSegmentByIdResponse> {
            return localVarFp.updateSegmentById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the settings for a specific list.
         * @summary Update lists
         * @param {ListsApiUpdateSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(requestParameters: ListsApiUpdateSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateSettingsResponse> {
            return localVarFp.updateSettings(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the settings for an existing webhook.
         * @summary Update webhook
         * @param {ListsApiUpdateWebhookSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookSettings(requestParameters: ListsApiUpdateWebhookSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsUpdateWebhookSettingsResponse> {
            return localVarFp.updateWebhookSettings(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity
         * @param {ListsApiViewRecentActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRecentActivity(requestParameters: ListsApiViewRecentActivityRequest, options?: AxiosRequestConfig): AxiosPromise<ListsViewRecentActivityResponse> {
            return localVarFp.viewRecentActivity(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the last 50 events of a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
         * @summary View recent activity 50
         * @param {ListsApiViewRecentActivityEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewRecentActivityEvents(requestParameters: ListsApiViewRecentActivityEventsRequest, options?: AxiosRequestConfig): AxiosPromise<ListsViewRecentActivityEventsResponse> {
            return localVarFp.viewRecentActivityEvents(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addInterestCategory operation in ListsApi.
 * @export
 * @interface ListsApiAddInterestCategoryRequest
 */
export type ListsApiAddInterestCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddInterestCategory
    */
    readonly listId: string
    
} & ListsAddInterestCategoryRequest

/**
 * Request parameters for addInterestInCategory operation in ListsApi.
 * @export
 * @interface ListsApiAddInterestInCategoryRequest
 */
export type ListsApiAddInterestInCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddInterestInCategory
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiAddInterestInCategory
    */
    readonly interestCategoryId: string
    
} & ListsAddInterestInCategoryRequest

/**
 * Request parameters for addMemberEvent operation in ListsApi.
 * @export
 * @interface ListsApiAddMemberEventRequest
 */
export type ListsApiAddMemberEventRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMemberEvent
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiAddMemberEvent
    */
    readonly subscriberHash: string
    
} & ListsAddMemberEventRequest

/**
 * Request parameters for addMemberNote operation in ListsApi.
 * @export
 * @interface ListsApiAddMemberNoteRequest
 */
export type ListsApiAddMemberNoteRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMemberNote
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address.
    * @type {string}
    * @memberof ListsApiAddMemberNote
    */
    readonly subscriberHash: string
    
} & ListsAddMemberNoteRequest

/**
 * Request parameters for addMemberTags operation in ListsApi.
 * @export
 * @interface ListsApiAddMemberTagsRequest
 */
export type ListsApiAddMemberTagsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMemberTags
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address.
    * @type {string}
    * @memberof ListsApiAddMemberTags
    */
    readonly subscriberHash: string
    
} & ListsAddMemberTagsRequest

/**
 * Request parameters for addMemberToList operation in ListsApi.
 * @export
 * @interface ListsApiAddMemberToListRequest
 */
export type ListsApiAddMemberToListRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMemberToList
    */
    readonly listId: string
    
    /**
    * If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
    * @type {boolean}
    * @memberof ListsApiAddMemberToList
    */
    readonly skipMergeValidation?: boolean
    
} & ListsAddMemberToListRequest

/**
 * Request parameters for addMemberToSegment operation in ListsApi.
 * @export
 * @interface ListsApiAddMemberToSegmentRequest
 */
export type ListsApiAddMemberToSegmentRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMemberToSegment
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiAddMemberToSegment
    */
    readonly segmentId: string
    
} & ListsAddMemberToSegmentRequest

/**
 * Request parameters for addMergeField operation in ListsApi.
 * @export
 * @interface ListsApiAddMergeFieldRequest
 */
export type ListsApiAddMergeFieldRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddMergeField
    */
    readonly listId: string
    
} & ListsAddMergeFieldRequest

/**
 * Request parameters for addNewSegment operation in ListsApi.
 * @export
 * @interface ListsApiAddNewSegmentRequest
 */
export type ListsApiAddNewSegmentRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddNewSegment
    */
    readonly listId: string
    
} & ListsAddNewSegmentRequest

/**
 * Request parameters for addOrUpdateMember operation in ListsApi.
 * @export
 * @interface ListsApiAddOrUpdateMemberRequest
 */
export type ListsApiAddOrUpdateMemberRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiAddOrUpdateMember
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiAddOrUpdateMember
    */
    readonly subscriberHash: string
    
    /**
    * If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
    * @type {boolean}
    * @memberof ListsApiAddOrUpdateMember
    */
    readonly skipMergeValidation?: boolean
    
} & ListsAddOrUpdateMemberRequest

/**
 * Request parameters for archiveMember operation in ListsApi.
 * @export
 * @interface ListsApiArchiveMemberRequest
 */
export type ListsApiArchiveMemberRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiArchiveMember
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiArchiveMember
    */
    readonly subscriberHash: string
    
}

/**
 * Request parameters for batchAddRemoveMembers operation in ListsApi.
 * @export
 * @interface ListsApiBatchAddRemoveMembersRequest
 */
export type ListsApiBatchAddRemoveMembersRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiBatchAddRemoveMembers
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiBatchAddRemoveMembers
    */
    readonly segmentId: string
    
} & ListsBatchAddRemoveMembersRequest

/**
 * Request parameters for batchSubscribeOrUnsubscribe operation in ListsApi.
 * @export
 * @interface ListsApiBatchSubscribeOrUnsubscribeRequest
 */
export type ListsApiBatchSubscribeOrUnsubscribeRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiBatchSubscribeOrUnsubscribe
    */
    readonly listId: string
    
    /**
    * If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
    * @type {boolean}
    * @memberof ListsApiBatchSubscribeOrUnsubscribe
    */
    readonly skipMergeValidation?: boolean
    
    /**
    * If skip_duplicate_check is true, we will ignore duplicates sent in the request when using the batch sub/unsub on the lists endpoint. The status of the first appearance in the request will be saved. This defaults to false.
    * @type {boolean}
    * @memberof ListsApiBatchSubscribeOrUnsubscribe
    */
    readonly skipDuplicateCheck?: boolean
    
} & ListsBatchSubscribeOrUnsubscribeRequest

/**
 * Request parameters for createNewList operation in ListsApi.
 * @export
 * @interface ListsApiCreateNewListRequest
 */
export type ListsApiCreateNewListRequest = {
    
} & ListsCreateNewListRequest

/**
 * Request parameters for createWebhook operation in ListsApi.
 * @export
 * @interface ListsApiCreateWebhookRequest
 */
export type ListsApiCreateWebhookRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiCreateWebhook
    */
    readonly listId: string
    
} & ListsCreateWebhookRequest

/**
 * Request parameters for customizeSignupForm operation in ListsApi.
 * @export
 * @interface ListsApiCustomizeSignupFormRequest
 */
export type ListsApiCustomizeSignupFormRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiCustomizeSignupForm
    */
    readonly listId: string
    
} & ListsCustomizeSignupFormRequest

/**
 * Request parameters for deleteInterestCategory operation in ListsApi.
 * @export
 * @interface ListsApiDeleteInterestCategoryRequest
 */
export type ListsApiDeleteInterestCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteInterestCategory
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiDeleteInterestCategory
    */
    readonly interestCategoryId: string
    
}

/**
 * Request parameters for deleteInterestInCategory operation in ListsApi.
 * @export
 * @interface ListsApiDeleteInterestInCategoryRequest
 */
export type ListsApiDeleteInterestInCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteInterestInCategory
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiDeleteInterestInCategory
    */
    readonly interestCategoryId: string
    
    /**
    * The specific interest or \'group name\'.
    * @type {string}
    * @memberof ListsApiDeleteInterestInCategory
    */
    readonly interestId: string
    
}

/**
 * Request parameters for deleteList operation in ListsApi.
 * @export
 * @interface ListsApiDeleteListRequest
 */
export type ListsApiDeleteListRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteList
    */
    readonly listId: string
    
}

/**
 * Request parameters for deleteMergeField operation in ListsApi.
 * @export
 * @interface ListsApiDeleteMergeFieldRequest
 */
export type ListsApiDeleteMergeFieldRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteMergeField
    */
    readonly listId: string
    
    /**
    * The id for the merge field.
    * @type {string}
    * @memberof ListsApiDeleteMergeField
    */
    readonly mergeId: string
    
}

/**
 * Request parameters for deleteNote operation in ListsApi.
 * @export
 * @interface ListsApiDeleteNoteRequest
 */
export type ListsApiDeleteNoteRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteNote
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiDeleteNote
    */
    readonly subscriberHash: string
    
    /**
    * The id for the note.
    * @type {string}
    * @memberof ListsApiDeleteNote
    */
    readonly noteId: string
    
}

/**
 * Request parameters for deleteSegment operation in ListsApi.
 * @export
 * @interface ListsApiDeleteSegmentRequest
 */
export type ListsApiDeleteSegmentRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteSegment
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiDeleteSegment
    */
    readonly segmentId: string
    
}

/**
 * Request parameters for deleteWebhook operation in ListsApi.
 * @export
 * @interface ListsApiDeleteWebhookRequest
 */
export type ListsApiDeleteWebhookRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiDeleteWebhook
    */
    readonly listId: string
    
    /**
    * The webhook\'s id.
    * @type {string}
    * @memberof ListsApiDeleteWebhook
    */
    readonly webhookId: string
    
}

/**
 * Request parameters for getAbuseReport operation in ListsApi.
 * @export
 * @interface ListsApiGetAbuseReportRequest
 */
export type ListsApiGetAbuseReportRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetAbuseReport
    */
    readonly listId: string
    
    /**
    * The id for the abuse report.
    * @type {string}
    * @memberof ListsApiGetAbuseReport
    */
    readonly reportId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAbuseReport
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAbuseReport
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetAbuseReport
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetAbuseReport
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getAllAbuseReports operation in ListsApi.
 * @export
 * @interface ListsApiGetAllAbuseReportsRequest
 */
export type ListsApiGetAllAbuseReportsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetAllAbuseReports
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAllAbuseReports
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAllAbuseReports
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetAllAbuseReports
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetAllAbuseReports
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getAllInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetAllInfoRequest
 */
export type ListsApiGetAllInfoRequest = {
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAllInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetAllInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetAllInfo
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetAllInfo
    */
    readonly offset?: number
    
    /**
    * Restrict response to lists created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetAllInfo
    */
    readonly beforeDateCreated?: string
    
    /**
    * Restrict results to lists created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetAllInfo
    */
    readonly sinceDateCreated?: string
    
    /**
    * Restrict results to lists created before the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetAllInfo
    */
    readonly beforeCampaignLastSent?: string
    
    /**
    * Restrict results to lists created after the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetAllInfo
    */
    readonly sinceCampaignLastSent?: string
    
    /**
    * Restrict results to lists that include a specific subscriber\'s email address.
    * @type {string}
    * @memberof ListsApiGetAllInfo
    */
    readonly email?: string
    
    /**
    * Returns files sorted by the specified field.
    * @type {'date_created'}
    * @memberof ListsApiGetAllInfo
    */
    readonly sortField?: 'date_created'
    
    /**
    * Determines the order direction for sorted results.
    * @type {'ASC' | 'DESC'}
    * @memberof ListsApiGetAllInfo
    */
    readonly sortDir?: 'ASC' | 'DESC'
    
    /**
    * Restrict results to lists that contain an active, connected, undeleted ecommerce store.
    * @type {boolean}
    * @memberof ListsApiGetAllInfo
    */
    readonly hasEcommerceStore?: boolean
    
    /**
    * Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
    * @type {boolean}
    * @memberof ListsApiGetAllInfo
    */
    readonly includeTotalContacts?: boolean
    
}

/**
 * Request parameters for getGrowthHistoryByMonth operation in ListsApi.
 * @export
 * @interface ListsApiGetGrowthHistoryByMonthRequest
 */
export type ListsApiGetGrowthHistoryByMonthRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetGrowthHistoryByMonth
    */
    readonly listId: string
    
    /**
    * A specific month of list growth history.
    * @type {string}
    * @memberof ListsApiGetGrowthHistoryByMonth
    */
    readonly month: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetGrowthHistoryByMonth
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetGrowthHistoryByMonth
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getGrowthHistoryData operation in ListsApi.
 * @export
 * @interface ListsApiGetGrowthHistoryDataRequest
 */
export type ListsApiGetGrowthHistoryDataRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly offset?: number
    
    /**
    * Returns files sorted by the specified field.
    * @type {'month'}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly sortField?: 'month'
    
    /**
    * Determines the order direction for sorted results.
    * @type {'ASC' | 'DESC'}
    * @memberof ListsApiGetGrowthHistoryData
    */
    readonly sortDir?: 'ASC' | 'DESC'
    
}

/**
 * Request parameters for getInterestCategoryInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetInterestCategoryInfoRequest
 */
export type ListsApiGetInterestCategoryInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetInterestCategoryInfo
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiGetInterestCategoryInfo
    */
    readonly interestCategoryId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetInterestCategoryInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetInterestCategoryInfo
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getInterestInCategory operation in ListsApi.
 * @export
 * @interface ListsApiGetInterestInCategoryRequest
 */
export type ListsApiGetInterestInCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetInterestInCategory
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiGetInterestInCategory
    */
    readonly interestCategoryId: string
    
    /**
    * The specific interest or \'group name\'.
    * @type {string}
    * @memberof ListsApiGetInterestInCategory
    */
    readonly interestId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetInterestInCategory
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetInterestInCategory
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getListInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetListInfoRequest
 */
export type ListsApiGetListInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetListInfo
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetListInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetListInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
    * @type {boolean}
    * @memberof ListsApiGetListInfo
    */
    readonly includeTotalContacts?: boolean
    
}

/**
 * Request parameters for getLocations operation in ListsApi.
 * @export
 * @interface ListsApiGetLocationsRequest
 */
export type ListsApiGetLocationsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetLocations
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetLocations
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetLocations
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getMemberEvents operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberEventsRequest
 */
export type ListsApiGetMemberEventsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberEvents
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiGetMemberEvents
    */
    readonly subscriberHash: string
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetMemberEvents
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetMemberEvents
    */
    readonly offset?: number
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberEvents
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberEvents
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getMemberGoals operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberGoalsRequest
 */
export type ListsApiGetMemberGoalsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberGoals
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiGetMemberGoals
    */
    readonly subscriberHash: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberGoals
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberGoals
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getMemberInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberInfoRequest
 */
export type ListsApiGetMemberInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberInfo
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiGetMemberInfo
    */
    readonly subscriberHash: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberInfo
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getMemberNote operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberNoteRequest
 */
export type ListsApiGetMemberNoteRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberNote
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiGetMemberNote
    */
    readonly subscriberHash: string
    
    /**
    * The id for the note.
    * @type {string}
    * @memberof ListsApiGetMemberNote
    */
    readonly noteId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberNote
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberNote
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getMemberNotes operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberNotesRequest
 */
export type ListsApiGetMemberNotesRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberNotes
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address.
    * @type {string}
    * @memberof ListsApiGetMemberNotes
    */
    readonly subscriberHash: string
    
    /**
    * Returns notes sorted by the specified field.
    * @type {'created_at' | 'updated_at' | 'note_id'}
    * @memberof ListsApiGetMemberNotes
    */
    readonly sortField?: 'created_at' | 'updated_at' | 'note_id'
    
    /**
    * Determines the order direction for sorted results.
    * @type {'ASC' | 'DESC'}
    * @memberof ListsApiGetMemberNotes
    */
    readonly sortDir?: 'ASC' | 'DESC'
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberNotes
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberNotes
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetMemberNotes
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetMemberNotes
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getMemberTags operation in ListsApi.
 * @export
 * @interface ListsApiGetMemberTagsRequest
 */
export type ListsApiGetMemberTagsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMemberTags
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiGetMemberTags
    */
    readonly subscriberHash: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberTags
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMemberTags
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetMemberTags
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetMemberTags
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getMembersInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetMembersInfoRequest
 */
export type ListsApiGetMembersInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMembersInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMembersInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetMembersInfo
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetMembersInfo
    */
    readonly offset?: number
    
    /**
    * The email type.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly emailType?: string
    
    /**
    * The subscriber\'s status.
    * @type {'subscribed' | 'unsubscribed' | 'cleaned' | 'pending' | 'transactional' | 'archived'}
    * @memberof ListsApiGetMembersInfo
    */
    readonly status?: 'subscribed' | 'unsubscribed' | 'cleaned' | 'pending' | 'transactional' | 'archived'
    
    /**
    * Restrict results to subscribers who opted-in after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly sinceTimestampOpt?: string
    
    /**
    * Restrict results to subscribers who opted-in before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly beforeTimestampOpt?: string
    
    /**
    * Restrict results to subscribers whose information changed after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly sinceLastChanged?: string
    
    /**
    * Restrict results to subscribers whose information changed before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly beforeLastChanged?: string
    
    /**
    * A unique identifier for the email address across all Mailchimp lists.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly uniqueEmailId?: string
    
    /**
    * A filter to return only the list\'s VIP members. Passing `true` will restrict results to VIP list members, passing `false` will return all list members.
    * @type {boolean}
    * @memberof ListsApiGetMembersInfo
    */
    readonly vipOnly?: boolean
    
    /**
    * The unique id for the interest category.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly interestCategoryId?: string
    
    /**
    * Used to filter list members by interests. Must be accompanied by interest_category_id and interest_match. The value must be a comma separated list of interest ids present for any supplied interest categories.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly interestIds?: string
    
    /**
    * Used to filter list members by interests. Must be accompanied by interest_category_id and interest_ids. \"any\" will match a member with any of the interest supplied, \"all\" will only match members with every interest supplied, and \"none\" will match members without any of the interest supplied.
    * @type {'any' | 'all' | 'none'}
    * @memberof ListsApiGetMembersInfo
    */
    readonly interestMatch?: 'any' | 'all' | 'none'
    
    /**
    * Returns files sorted by the specified field.
    * @type {'timestamp_opt' | 'timestamp_signup' | 'last_changed'}
    * @memberof ListsApiGetMembersInfo
    */
    readonly sortField?: 'timestamp_opt' | 'timestamp_signup' | 'last_changed'
    
    /**
    * Determines the order direction for sorted results.
    * @type {'ASC' | 'DESC'}
    * @memberof ListsApiGetMembersInfo
    */
    readonly sortDir?: 'ASC' | 'DESC'
    
    /**
    * Filter subscribers by those subscribed/unsubscribed/pending/cleaned since last email campaign send. Member status is required to use this filter.
    * @type {boolean}
    * @memberof ListsApiGetMembersInfo
    */
    readonly sinceLastCampaign?: boolean
    
    /**
    * Filter subscribers by those unsubscribed since a specific date. Using any status other than unsubscribed with this filter will result in an error.
    * @type {string}
    * @memberof ListsApiGetMembersInfo
    */
    readonly unsubscribedSince?: string
    
}

/**
 * Request parameters for getMergeFieldInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetMergeFieldInfoRequest
 */
export type ListsApiGetMergeFieldInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetMergeFieldInfo
    */
    readonly listId: string
    
    /**
    * The id for the merge field.
    * @type {string}
    * @memberof ListsApiGetMergeFieldInfo
    */
    readonly mergeId: string
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMergeFieldInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetMergeFieldInfo
    */
    readonly fields?: Array<string>
    
}

/**
 * Request parameters for getRecentActivityStats operation in ListsApi.
 * @export
 * @interface ListsApiGetRecentActivityStatsRequest
 */
export type ListsApiGetRecentActivityStatsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetRecentActivityStats
    */
    readonly listId: string
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetRecentActivityStats
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetRecentActivityStats
    */
    readonly offset?: number
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetRecentActivityStats
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetRecentActivityStats
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for getSegmentInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetSegmentInfoRequest
 */
export type ListsApiGetSegmentInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly segmentId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * Include cleaned members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly includeCleaned?: boolean
    
    /**
    * Include transactional members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly includeTransactional?: boolean
    
    /**
    * Include unsubscribed members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentInfo
    */
    readonly includeUnsubscribed?: boolean
    
}

/**
 * Request parameters for getSegmentMembers operation in ListsApi.
 * @export
 * @interface ListsApiGetSegmentMembersRequest
 */
export type ListsApiGetSegmentMembersRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly segmentId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly offset?: number
    
    /**
    * Include cleaned members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly includeCleaned?: boolean
    
    /**
    * Include transactional members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly includeTransactional?: boolean
    
    /**
    * Include unsubscribed members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentMembers
    */
    readonly includeUnsubscribed?: boolean
    
}

/**
 * Request parameters for getSegmentsInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetSegmentsInfoRequest
 */
export type ListsApiGetSegmentsInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly offset?: number
    
    /**
    * Limit results based on segment type.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly type?: string
    
    /**
    * Restrict results to segments created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly sinceCreatedAt?: string
    
    /**
    * Restrict results to segments created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly beforeCreatedAt?: string
    
    /**
    * Include cleaned members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly includeCleaned?: boolean
    
    /**
    * Include transactional members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly includeTransactional?: boolean
    
    /**
    * Include unsubscribed members in response
    * @type {boolean}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly includeUnsubscribed?: boolean
    
    /**
    * Restrict results to segments update after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly sinceUpdatedAt?: string
    
    /**
    * Restrict results to segments update before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof ListsApiGetSegmentsInfo
    */
    readonly beforeUpdatedAt?: string
    
}

/**
 * Request parameters for getSignupForms operation in ListsApi.
 * @export
 * @interface ListsApiGetSignupFormsRequest
 */
export type ListsApiGetSignupFormsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSignupForms
    */
    readonly listId: string
    
}

/**
 * Request parameters for getSurveyDetails operation in ListsApi.
 * @export
 * @interface ListsApiGetSurveyDetailsRequest
 */
export type ListsApiGetSurveyDetailsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSurveyDetails
    */
    readonly listId: string
    
    /**
    * The ID of the survey.
    * @type {string}
    * @memberof ListsApiGetSurveyDetails
    */
    readonly surveyId: string
    
}

/**
 * Request parameters for getSurveysInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetSurveysInfoRequest
 */
export type ListsApiGetSurveysInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetSurveysInfo
    */
    readonly listId: string
    
}

/**
 * Request parameters for getWebhookInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetWebhookInfoRequest
 */
export type ListsApiGetWebhookInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetWebhookInfo
    */
    readonly listId: string
    
    /**
    * The webhook\'s id.
    * @type {string}
    * @memberof ListsApiGetWebhookInfo
    */
    readonly webhookId: string
    
}

/**
 * Request parameters for getWebhooksInfo operation in ListsApi.
 * @export
 * @interface ListsApiGetWebhooksInfoRequest
 */
export type ListsApiGetWebhooksInfoRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiGetWebhooksInfo
    */
    readonly listId: string
    
}

/**
 * Request parameters for listCategoryInterests operation in ListsApi.
 * @export
 * @interface ListsApiListCategoryInterestsRequest
 */
export type ListsApiListCategoryInterestsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiListCategoryInterests
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiListCategoryInterests
    */
    readonly interestCategoryId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListCategoryInterests
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListCategoryInterests
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiListCategoryInterests
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiListCategoryInterests
    */
    readonly offset?: number
    
}

/**
 * Request parameters for listInterestCategories operation in ListsApi.
 * @export
 * @interface ListsApiListInterestCategoriesRequest
 */
export type ListsApiListInterestCategoriesRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiListInterestCategories
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListInterestCategories
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListInterestCategories
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiListInterestCategories
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiListInterestCategories
    */
    readonly offset?: number
    
    /**
    * Restrict results a type of interest group
    * @type {string}
    * @memberof ListsApiListInterestCategories
    */
    readonly type?: string
    
}

/**
 * Request parameters for listMergeFields operation in ListsApi.
 * @export
 * @interface ListsApiListMergeFieldsRequest
 */
export type ListsApiListMergeFieldsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiListMergeFields
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListMergeFields
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListMergeFields
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiListMergeFields
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiListMergeFields
    */
    readonly offset?: number
    
    /**
    * The merge field type.
    * @type {string}
    * @memberof ListsApiListMergeFields
    */
    readonly type?: string
    
    /**
    * Whether it\'s a required merge field.
    * @type {boolean}
    * @memberof ListsApiListMergeFields
    */
    readonly required?: boolean
    
}

/**
 * Request parameters for listTopEmailClients operation in ListsApi.
 * @export
 * @interface ListsApiListTopEmailClientsRequest
 */
export type ListsApiListTopEmailClientsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiListTopEmailClients
    */
    readonly listId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListTopEmailClients
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiListTopEmailClients
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for removeMemberFromSegment operation in ListsApi.
 * @export
 * @interface ListsApiRemoveMemberFromSegmentRequest
 */
export type ListsApiRemoveMemberFromSegmentRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiRemoveMemberFromSegment
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiRemoveMemberFromSegment
    */
    readonly segmentId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address.
    * @type {string}
    * @memberof ListsApiRemoveMemberFromSegment
    */
    readonly subscriberHash: string
    
}

/**
 * Request parameters for removeMemberPermanent operation in ListsApi.
 * @export
 * @interface ListsApiRemoveMemberPermanentRequest
 */
export type ListsApiRemoveMemberPermanentRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiRemoveMemberPermanent
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address.
    * @type {string}
    * @memberof ListsApiRemoveMemberPermanent
    */
    readonly subscriberHash: string
    
}

/**
 * Request parameters for searchTagsByName operation in ListsApi.
 * @export
 * @interface ListsApiSearchTagsByNameRequest
 */
export type ListsApiSearchTagsByNameRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiSearchTagsByName
    */
    readonly listId: string
    
    /**
    * The search query used to filter tags.  The search query will be compared to each tag as a prefix, so all tags that have a name starting with this field will be returned.
    * @type {string}
    * @memberof ListsApiSearchTagsByName
    */
    readonly name?: string
    
}

/**
 * Request parameters for updateInterestCategory operation in ListsApi.
 * @export
 * @interface ListsApiUpdateInterestCategoryRequest
 */
export type ListsApiUpdateInterestCategoryRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateInterestCategory
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiUpdateInterestCategory
    */
    readonly interestCategoryId: string
    
} & ListsAddInterestCategoryRequest

/**
 * Request parameters for updateInterestCategoryInterest operation in ListsApi.
 * @export
 * @interface ListsApiUpdateInterestCategoryInterestRequest
 */
export type ListsApiUpdateInterestCategoryInterestRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateInterestCategoryInterest
    */
    readonly listId: string
    
    /**
    * The unique ID for the interest category.
    * @type {string}
    * @memberof ListsApiUpdateInterestCategoryInterest
    */
    readonly interestCategoryId: string
    
    /**
    * The specific interest or \'group name\'.
    * @type {string}
    * @memberof ListsApiUpdateInterestCategoryInterest
    */
    readonly interestId: string
    
} & ListsAddInterestInCategoryRequest

/**
 * Request parameters for updateMember operation in ListsApi.
 * @export
 * @interface ListsApiUpdateMemberRequest
 */
export type ListsApiUpdateMemberRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateMember
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiUpdateMember
    */
    readonly subscriberHash: string
    
    /**
    * If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
    * @type {boolean}
    * @memberof ListsApiUpdateMember
    */
    readonly skipMergeValidation?: boolean
    
} & ListsUpdateMemberRequest

/**
 * Request parameters for updateMergeField operation in ListsApi.
 * @export
 * @interface ListsApiUpdateMergeFieldRequest
 */
export type ListsApiUpdateMergeFieldRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateMergeField
    */
    readonly listId: string
    
    /**
    * The id for the merge field.
    * @type {string}
    * @memberof ListsApiUpdateMergeField
    */
    readonly mergeId: string
    
} & ListsUpdateMergeFieldRequest

/**
 * Request parameters for updateNoteSpecificListMember operation in ListsApi.
 * @export
 * @interface ListsApiUpdateNoteSpecificListMemberRequest
 */
export type ListsApiUpdateNoteSpecificListMemberRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateNoteSpecificListMember
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiUpdateNoteSpecificListMember
    */
    readonly subscriberHash: string
    
    /**
    * The id for the note.
    * @type {string}
    * @memberof ListsApiUpdateNoteSpecificListMember
    */
    readonly noteId: string
    
} & ListsAddMemberNoteRequest

/**
 * Request parameters for updateSegmentById operation in ListsApi.
 * @export
 * @interface ListsApiUpdateSegmentByIdRequest
 */
export type ListsApiUpdateSegmentByIdRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateSegmentById
    */
    readonly listId: string
    
    /**
    * The unique id for the segment.
    * @type {string}
    * @memberof ListsApiUpdateSegmentById
    */
    readonly segmentId: string
    
} & ListsUpdateSegmentByIdRequest

/**
 * Request parameters for updateSettings operation in ListsApi.
 * @export
 * @interface ListsApiUpdateSettingsRequest
 */
export type ListsApiUpdateSettingsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateSettings
    */
    readonly listId: string
    
} & ListsUpdateSettingsRequest

/**
 * Request parameters for updateWebhookSettings operation in ListsApi.
 * @export
 * @interface ListsApiUpdateWebhookSettingsRequest
 */
export type ListsApiUpdateWebhookSettingsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiUpdateWebhookSettings
    */
    readonly listId: string
    
    /**
    * The webhook\'s id.
    * @type {string}
    * @memberof ListsApiUpdateWebhookSettings
    */
    readonly webhookId: string
    
} & ListsCreateWebhookRequest

/**
 * Request parameters for viewRecentActivity operation in ListsApi.
 * @export
 * @interface ListsApiViewRecentActivityRequest
 */
export type ListsApiViewRecentActivityRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiViewRecentActivity
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiViewRecentActivity
    */
    readonly subscriberHash: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivity
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivity
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof ListsApiViewRecentActivity
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof ListsApiViewRecentActivity
    */
    readonly offset?: number
    
    /**
    * A comma-separated list of activity filters that correspond to a set of activity types, e.g \"?activity_filters=open,bounce,click\".
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivity
    */
    readonly activityFilters?: Array<string>
    
}

/**
 * Request parameters for viewRecentActivityEvents operation in ListsApi.
 * @export
 * @interface ListsApiViewRecentActivityEventsRequest
 */
export type ListsApiViewRecentActivityEventsRequest = {
    
    /**
    * The unique ID for the list.
    * @type {string}
    * @memberof ListsApiViewRecentActivityEvents
    */
    readonly listId: string
    
    /**
    * The MD5 hash of the lowercase version of the list member\'s email address. This endpoint also accepts a list member\'s email address or contact_id.
    * @type {string}
    * @memberof ListsApiViewRecentActivityEvents
    */
    readonly subscriberHash: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivityEvents
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivityEvents
    */
    readonly excludeFields?: Array<string>
    
    /**
    * A comma seperated list of actions to return.
    * @type {Array<string>}
    * @memberof ListsApiViewRecentActivityEvents
    */
    readonly action?: Array<string>
    
}

/**
 * ListsApiGenerated - object-oriented interface
 * @export
 * @class ListsApiGenerated
 * @extends {BaseAPI}
 */
export class ListsApiGenerated extends BaseAPI {
    /**
     * Create a new interest category.
     * @summary Add interest category
     * @param {ListsApiAddInterestCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addInterestCategory(requestParameters: ListsApiAddInterestCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addInterestCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new interest or \'group name\' for a specific category.
     * @summary Add interest in category
     * @param {ListsApiAddInterestInCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addInterestInCategory(requestParameters: ListsApiAddInterestInCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addInterestInCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an event for a list member.
     * @summary Add event
     * @param {ListsApiAddMemberEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMemberEvent(requestParameters: ListsApiAddMemberEventRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMemberEvent(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new note for a specific subscriber.
     * @summary Add member note
     * @param {ListsApiAddMemberNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMemberNote(requestParameters: ListsApiAddMemberNoteRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMemberNote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove tags from a list member. If a tag that does not exist is passed in and set as \'active\', a new tag will be created.
     * @summary Add or remove member tags
     * @param {ListsApiAddMemberTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMemberTags(requestParameters: ListsApiAddMemberTagsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMemberTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new member to the list.
     * @summary Add member to list
     * @param {ListsApiAddMemberToListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMemberToList(requestParameters: ListsApiAddMemberToListRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMemberToList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a member to a static segment.
     * @summary Add member to segment
     * @param {ListsApiAddMemberToSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMemberToSegment(requestParameters: ListsApiAddMemberToSegmentRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMemberToSegment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new merge field for a specific audience.
     * @summary Add merge field
     * @param {ListsApiAddMergeFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addMergeField(requestParameters: ListsApiAddMergeFieldRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addMergeField(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new segment in a specific list.
     * @summary Add segment
     * @param {ListsApiAddNewSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addNewSegment(requestParameters: ListsApiAddNewSegmentRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addNewSegment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or update a list member.
     * @summary Add or update list member
     * @param {ListsApiAddOrUpdateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public addOrUpdateMember(requestParameters: ListsApiAddOrUpdateMemberRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).addOrUpdateMember(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive a list member. To permanently delete, use the delete-permanent action.
     * @summary Archive list member
     * @param {ListsApiArchiveMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public archiveMember(requestParameters: ListsApiArchiveMemberRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).archiveMember(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch add/remove list members to static segment
     * @summary Batch add or remove members
     * @param {ListsApiBatchAddRemoveMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public batchAddRemoveMembers(requestParameters: ListsApiBatchAddRemoveMembersRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).batchAddRemoveMembers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch subscribe or unsubscribe list members.
     * @summary Batch subscribe or unsubscribe
     * @param {ListsApiBatchSubscribeOrUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public batchSubscribeOrUnsubscribe(requestParameters: ListsApiBatchSubscribeOrUnsubscribeRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).batchSubscribeOrUnsubscribe(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new list in your Mailchimp account.
     * @summary Add list
     * @param {ListsApiCreateNewListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public createNewList(requestParameters: ListsApiCreateNewListRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).createNewList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new webhook for a specific list.
     * @summary Add webhook
     * @param {ListsApiCreateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public createWebhook(requestParameters: ListsApiCreateWebhookRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).createWebhook(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Customize a list\'s default signup form.
     * @summary Customize signup form
     * @param {ListsApiCustomizeSignupFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public customizeSignupForm(requestParameters: ListsApiCustomizeSignupFormRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).customizeSignupForm(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific interest category.
     * @summary Delete interest category
     * @param {ListsApiDeleteInterestCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteInterestCategory(requestParameters: ListsApiDeleteInterestCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteInterestCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete interests or group names in a specific category.
     * @summary Delete interest in category
     * @param {ListsApiDeleteInterestInCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteInterestInCategory(requestParameters: ListsApiDeleteInterestInCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteInterestInCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a list from your Mailchimp account. If you delete a list, you\'ll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.
     * @summary Delete list
     * @param {ListsApiDeleteListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteList(requestParameters: ListsApiDeleteListRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific merge field.
     * @summary Delete merge field
     * @param {ListsApiDeleteMergeFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteMergeField(requestParameters: ListsApiDeleteMergeFieldRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteMergeField(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific note for a specific list member.
     * @summary Delete note
     * @param {ListsApiDeleteNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteNote(requestParameters: ListsApiDeleteNoteRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteNote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific segment in a list.
     * @summary Delete segment
     * @param {ListsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteSegment(requestParameters: ListsApiDeleteSegmentRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteSegment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific webhook in a list.
     * @summary Delete webhook
     * @param {ListsApiDeleteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public deleteWebhook(requestParameters: ListsApiDeleteWebhookRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteWebhook(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about a specific abuse report.
     * @summary Get abuse report
     * @param {ListsApiGetAbuseReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getAbuseReport(requestParameters: ListsApiGetAbuseReportRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getAbuseReport(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all abuse reports for a specific list.
     * @summary List abuse reports
     * @param {ListsApiGetAllAbuseReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getAllAbuseReports(requestParameters: ListsApiGetAllAbuseReportsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getAllAbuseReports(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all lists in the account.
     * @summary Get lists info
     * @param {ListsApiGetAllInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getAllInfo(requestParameters: ListsApiGetAllInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getAllInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a summary of a specific list\'s growth activity for a specific month and year.
     * @summary Get growth history by month
     * @param {ListsApiGetGrowthHistoryByMonthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getGrowthHistoryByMonth(requestParameters: ListsApiGetGrowthHistoryByMonthRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getGrowthHistoryByMonth(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a month-by-month summary of a specific list\'s growth activity.
     * @summary List growth history data
     * @param {ListsApiGetGrowthHistoryDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getGrowthHistoryData(requestParameters: ListsApiGetGrowthHistoryDataRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getGrowthHistoryData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific interest category.
     * @summary Get interest category info
     * @param {ListsApiGetInterestCategoryInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getInterestCategoryInfo(requestParameters: ListsApiGetInterestCategoryInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getInterestCategoryInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get interests or \'group names\' for a specific category.
     * @summary Get interest in category
     * @param {ListsApiGetInterestInCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getInterestInCategory(requestParameters: ListsApiGetInterestInCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getInterestInCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven\'t confirmed their subscription yet and unsubscribed or cleaned.
     * @summary Get list info
     * @param {ListsApiGetListInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getListInfo(requestParameters: ListsApiGetListInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the locations (countries) that the list\'s subscribers have been tagged to based on geocoding their IP address.
     * @summary List locations
     * @param {ListsApiGetLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getLocations(requestParameters: ListsApiGetLocationsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getLocations(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get events for a contact.
     * @summary List member events
     * @param {ListsApiGetMemberEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberEvents(requestParameters: ListsApiGetMemberEventsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberEvents(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last 50 Goal events for a member on a specific list.
     * @summary List member goal events
     * @param {ListsApiGetMemberGoalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberGoals(requestParameters: ListsApiGetMemberGoalsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberGoals(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.
     * @summary Get member info
     * @param {ListsApiGetMemberInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberInfo(requestParameters: ListsApiGetMemberInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific note for a specific list member.
     * @summary Get member note
     * @param {ListsApiGetMemberNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberNote(requestParameters: ListsApiGetMemberNoteRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberNote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent notes for a specific list member.
     * @summary List recent member notes
     * @param {ListsApiGetMemberNotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberNotes(requestParameters: ListsApiGetMemberNotesRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberNotes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tags on a list member.
     * @summary List member tags
     * @param {ListsApiGetMemberTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMemberTags(requestParameters: ListsApiGetMemberTagsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMemberTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about members in a specific Mailchimp list.
     * @summary List members info
     * @param {ListsApiGetMembersInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMembersInfo(requestParameters: ListsApiGetMembersInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMembersInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific merge field.
     * @summary Get merge field
     * @param {ListsApiGetMergeFieldInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getMergeFieldInfo(requestParameters: ListsApiGetMergeFieldInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getMergeFieldInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.
     * @summary List recent activity
     * @param {ListsApiGetRecentActivityStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getRecentActivityStats(requestParameters: ListsApiGetRecentActivityStatsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getRecentActivityStats(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific segment.
     * @summary Get segment info
     * @param {ListsApiGetSegmentInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSegmentInfo(requestParameters: ListsApiGetSegmentInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSegmentInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about members in a saved segment.
     * @summary List members in segment
     * @param {ListsApiGetSegmentMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSegmentMembers(requestParameters: ListsApiGetSegmentMembersRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSegmentMembers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all available segments for a specific list.
     * @summary List segments
     * @param {ListsApiGetSegmentsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSegmentsInfo(requestParameters: ListsApiGetSegmentsInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSegmentsInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get signup forms for a specific list.
     * @summary List signup forms
     * @param {ListsApiGetSignupFormsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSignupForms(requestParameters: ListsApiGetSignupFormsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSignupForms(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about a specific survey.
     * @summary Get survey
     * @param {ListsApiGetSurveyDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSurveyDetails(requestParameters: ListsApiGetSurveyDetailsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSurveyDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all available surveys for a specific list.
     * @summary Get information about all surveys for a list
     * @param {ListsApiGetSurveysInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getSurveysInfo(requestParameters: ListsApiGetSurveysInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getSurveysInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific webhook.
     * @summary Get webhook info
     * @param {ListsApiGetWebhookInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getWebhookInfo(requestParameters: ListsApiGetWebhookInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getWebhookInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about all webhooks for a specific list.
     * @summary List webhooks
     * @param {ListsApiGetWebhooksInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public getWebhooksInfo(requestParameters: ListsApiGetWebhooksInfoRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getWebhooksInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of this category\'s interests.
     * @summary List interests in category
     * @param {ListsApiListCategoryInterestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public listCategoryInterests(requestParameters: ListsApiListCategoryInterestsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listCategoryInterests(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a list\'s interest categories.
     * @summary List interest categories
     * @param {ListsApiListInterestCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public listInterestCategories(requestParameters: ListsApiListInterestCategoriesRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listInterestCategories(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all merge fields for an audience.
     * @summary List merge fields
     * @param {ListsApiListMergeFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public listMergeFields(requestParameters: ListsApiListMergeFieldsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listMergeFields(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the top email clients based on user-agent strings.
     * @summary List top email clients
     * @param {ListsApiListTopEmailClientsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public listTopEmailClients(requestParameters: ListsApiListTopEmailClientsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listTopEmailClients(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a member from the specified static segment.
     * @summary Remove list member from segment
     * @param {ListsApiRemoveMemberFromSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public removeMemberFromSegment(requestParameters: ListsApiRemoveMemberFromSegmentRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).removeMemberFromSegment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.
     * @summary Delete list member
     * @param {ListsApiRemoveMemberPermanentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public removeMemberPermanent(requestParameters: ListsApiRemoveMemberPermanentRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).removeMemberPermanent(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for tags on a list by name. If no name is provided, will return all tags on the list.
     * @summary Search for tags on a list by name.
     * @param {ListsApiSearchTagsByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public searchTagsByName(requestParameters: ListsApiSearchTagsByNameRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).searchTagsByName(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific interest category.
     * @summary Update interest category
     * @param {ListsApiUpdateInterestCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateInterestCategory(requestParameters: ListsApiUpdateInterestCategoryRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateInterestCategory(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update interests or \'group names\' for a specific category.
     * @summary Update interest in category
     * @param {ListsApiUpdateInterestCategoryInterestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateInterestCategoryInterest(requestParameters: ListsApiUpdateInterestCategoryInterestRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateInterestCategoryInterest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific list member.
     * @summary Update list member
     * @param {ListsApiUpdateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateMember(requestParameters: ListsApiUpdateMemberRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateMember(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific merge field.
     * @summary Update merge field
     * @param {ListsApiUpdateMergeFieldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateMergeField(requestParameters: ListsApiUpdateMergeFieldRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateMergeField(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific note for a specific list member.
     * @summary Update note
     * @param {ListsApiUpdateNoteSpecificListMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateNoteSpecificListMember(requestParameters: ListsApiUpdateNoteSpecificListMemberRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateNoteSpecificListMember(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific segment in a list.
     * @summary Update segment
     * @param {ListsApiUpdateSegmentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateSegmentById(requestParameters: ListsApiUpdateSegmentByIdRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateSegmentById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the settings for a specific list.
     * @summary Update lists
     * @param {ListsApiUpdateSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateSettings(requestParameters: ListsApiUpdateSettingsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateSettings(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the settings for an existing webhook.
     * @summary Update webhook
     * @param {ListsApiUpdateWebhookSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public updateWebhookSettings(requestParameters: ListsApiUpdateWebhookSettingsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateWebhookSettings(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
     * @summary View recent activity
     * @param {ListsApiViewRecentActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public viewRecentActivity(requestParameters: ListsApiViewRecentActivityRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).viewRecentActivity(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the last 50 events of a member\'s activity on a specific list, including opens, clicks, and unsubscribes.
     * @summary View recent activity 50
     * @param {ListsApiViewRecentActivityEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApiGenerated
     */
    public viewRecentActivityEvents(requestParameters: ListsApiViewRecentActivityEventsRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).viewRecentActivityEvents(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
