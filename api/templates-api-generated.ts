/* tslint:disable */
/* eslint-disable */
/*
Mailchimp Marketing API

Mailchimp is a marketing platform for small businesses. It offers an all-in-one marketing solution that includes email marketing, ads, landing pages, and automation. With Mailchimp, businesses can design and send targeted campaigns, analyze their performance, and grow their audience.

The version of the OpenAPI document: 3.0.55
Contact: apihelp@mailchimp.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { TemplatesCreateNewTemplate200Response } from '../models';
// @ts-ignore
import { TemplatesCreateNewTemplateRequest } from '../models';
// @ts-ignore
import { TemplatesCreateNewTemplateResponse } from '../models';
// @ts-ignore
import { TemplatesCreateNewTemplatedefaultResponse } from '../models';
// @ts-ignore
import { TemplatesDeleteSpecificTemplateResponse } from '../models';
// @ts-ignore
import { TemplatesDeleteSpecificTemplatedefaultResponse } from '../models';
// @ts-ignore
import { TemplatesGetInfo200Response } from '../models';
// @ts-ignore
import { TemplatesGetInfoResponse } from '../models';
// @ts-ignore
import { TemplatesGetInfodefaultResponse } from '../models';
// @ts-ignore
import { TemplatesListAvailableTemplates200Response } from '../models';
// @ts-ignore
import { TemplatesListAvailableTemplatesResponse } from '../models';
// @ts-ignore
import { TemplatesListAvailableTemplatesdefaultResponse } from '../models';
// @ts-ignore
import { TemplatesUpdateTemplateById200Response } from '../models';
// @ts-ignore
import { TemplatesUpdateTemplateByIdResponse } from '../models';
// @ts-ignore
import { TemplatesUpdateTemplateByIddefaultResponse } from '../models';
// @ts-ignore
import { TemplatesViewDefaultContent200Response } from '../models';
// @ts-ignore
import { TemplatesViewDefaultContentResponse } from '../models';
// @ts-ignore
import { TemplatesViewDefaultContentdefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new template for the account. Only Classic templates are supported.
         * @summary Add template
         * @param {TemplatesCreateNewTemplateRequest} templatesCreateNewTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTemplate: async (templatesCreateNewTemplateRequest: TemplatesCreateNewTemplateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templatesCreateNewTemplateRequest' is not null or undefined
            assertParamExists('createNewTemplate', 'templatesCreateNewTemplateRequest', templatesCreateNewTemplateRequest)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: templatesCreateNewTemplateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(templatesCreateNewTemplateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific template.
         * @summary Delete template
         * @param {string} templateId The unique id for the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificTemplate: async (templateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('deleteSpecificTemplate', 'templateId', templateId)
            const localVarPath = `/templates/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId !== undefined ? templateId : `-template_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates/{template_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific template.
         * @summary Get template info
         * @param {string} templateId The unique id for the template.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (templateId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getInfo', 'templateId', templateId)
            const localVarPath = `/templates/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId !== undefined ? templateId : `-template_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates/{template_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of an account\'s available templates.
         * @summary List templates
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {number} [count] The number of records to return. Default value is 10. Maximum value is 1000
         * @param {number} [offset] Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
         * @param {string} [createdBy] The Mailchimp account user who created the template.
         * @param {string} [sinceDateCreated] Restrict the response to templates created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [beforeDateCreated] Restrict the response to templates created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
         * @param {string} [type] Limit results based on template type.
         * @param {string} [category] Limit results based on category.
         * @param {string} [folderId] The unique folder id.
         * @param {'date_created' | 'date_edited' | 'name'} [sortField] Returns user templates sorted by the specified field.
         * @param {'html' | 'template' | 'multichannel'} [contentType] Limit results based on how the template\&#39;s content is put together. Only templates of type &#x60;user&#x60; can be filtered by &#x60;content_type&#x60;. If you want to retrieve saved templates created with the legacy email editor, then filter &#x60;content_type&#x60; to &#x60;template&#x60;. If you\&#39;d rather pull your saved templates for the new editor, filter to &#x60;multichannel&#x60;. For code your own templates, filter to &#x60;html&#x60;.
         * @param {'ASC' | 'DESC'} [sortDir] Determines the order direction for sorted results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableTemplates: async (fields?: Array<string>, excludeFields?: Array<string>, count?: number, offset?: number, createdBy?: string, sinceDateCreated?: string, beforeDateCreated?: string, type?: string, category?: string, folderId?: string, sortField?: 'date_created' | 'date_edited' | 'name', contentType?: 'html' | 'template' | 'multichannel', sortDir?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (sinceDateCreated !== undefined) {
                localVarQueryParameter['since_date_created'] = sinceDateCreated;
            }

            if (beforeDateCreated !== undefined) {
                localVarQueryParameter['before_date_created'] = beforeDateCreated;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folder_id'] = folderId;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sort_field'] = sortField;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the name, HTML, or `folder_id` of an existing template.
         * @summary Update template
         * @param {string} templateId The unique id for the template.
         * @param {TemplatesCreateNewTemplateRequest} templatesCreateNewTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateById: async (templateId: string, templatesCreateNewTemplateRequest: TemplatesCreateNewTemplateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('updateTemplateById', 'templateId', templateId)
            // verify required parameter 'templatesCreateNewTemplateRequest' is not null or undefined
            assertParamExists('updateTemplateById', 'templatesCreateNewTemplateRequest', templatesCreateNewTemplateRequest)
            const localVarPath = `/templates/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId !== undefined ? templateId : `-template_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: templatesCreateNewTemplateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates/{template_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(templatesCreateNewTemplateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the sections that you can edit in a template, including each section\'s default content.
         * @summary View default content
         * @param {string} templateId The unique id for the template.
         * @param {Array<string>} [fields] A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
         * @param {Array<string>} [excludeFields] A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultContent: async (templateId: string, fields?: Array<string>, excludeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('viewDefaultContent', 'templateId', templateId)
            const localVarPath = `/templates/{template_id}/default-content`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId !== undefined ? templateId : `-template_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/templates/{template_id}/default-content',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new template for the account. Only Classic templates are supported.
         * @summary Add template
         * @param {TemplatesApiCreateNewTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewTemplate(requestParameters: TemplatesApiCreateNewTemplateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesCreateNewTemplateResponse>> {
            const templatesCreateNewTemplateRequest: TemplatesCreateNewTemplateRequest = {
                name: requestParameters.name,
                folder_id: requestParameters.folder_id,
                html: requestParameters.html
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTemplate(templatesCreateNewTemplateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific template.
         * @summary Delete template
         * @param {TemplatesApiDeleteSpecificTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpecificTemplate(requestParameters: TemplatesApiDeleteSpecificTemplateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpecificTemplate(requestParameters.templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about a specific template.
         * @summary Get template info
         * @param {TemplatesApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(requestParameters: TemplatesApiGetInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesGetInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(requestParameters.templateId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of an account\'s available templates.
         * @summary List templates
         * @param {TemplatesApiListAvailableTemplatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableTemplates(requestParameters: TemplatesApiListAvailableTemplatesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesListAvailableTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableTemplates(requestParameters.fields, requestParameters.excludeFields, requestParameters.count, requestParameters.offset, requestParameters.createdBy, requestParameters.sinceDateCreated, requestParameters.beforeDateCreated, requestParameters.type, requestParameters.category, requestParameters.folderId, requestParameters.sortField, requestParameters.contentType, requestParameters.sortDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the name, HTML, or `folder_id` of an existing template.
         * @summary Update template
         * @param {TemplatesApiUpdateTemplateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplateById(requestParameters: TemplatesApiUpdateTemplateByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesUpdateTemplateByIdResponse>> {
            const templatesCreateNewTemplateRequest: TemplatesCreateNewTemplateRequest = {
                name: requestParameters.name,
                folder_id: requestParameters.folder_id,
                html: requestParameters.html
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplateById(requestParameters.templateId, templatesCreateNewTemplateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the sections that you can edit in a template, including each section\'s default content.
         * @summary View default content
         * @param {TemplatesApiViewDefaultContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewDefaultContent(requestParameters: TemplatesApiViewDefaultContentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesViewDefaultContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewDefaultContent(requestParameters.templateId, requestParameters.fields, requestParameters.excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Create a new template for the account. Only Classic templates are supported.
         * @summary Add template
         * @param {TemplatesApiCreateNewTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTemplate(requestParameters: TemplatesApiCreateNewTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesCreateNewTemplateResponse> {
            return localVarFp.createNewTemplate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific template.
         * @summary Delete template
         * @param {TemplatesApiDeleteSpecificTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpecificTemplate(requestParameters: TemplatesApiDeleteSpecificTemplateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSpecificTemplate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific template.
         * @summary Get template info
         * @param {TemplatesApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(requestParameters: TemplatesApiGetInfoRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesGetInfoResponse> {
            return localVarFp.getInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of an account\'s available templates.
         * @summary List templates
         * @param {TemplatesApiListAvailableTemplatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableTemplates(requestParameters: TemplatesApiListAvailableTemplatesRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesListAvailableTemplatesResponse> {
            return localVarFp.listAvailableTemplates(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the name, HTML, or `folder_id` of an existing template.
         * @summary Update template
         * @param {TemplatesApiUpdateTemplateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateById(requestParameters: TemplatesApiUpdateTemplateByIdRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesUpdateTemplateByIdResponse> {
            return localVarFp.updateTemplateById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the sections that you can edit in a template, including each section\'s default content.
         * @summary View default content
         * @param {TemplatesApiViewDefaultContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewDefaultContent(requestParameters: TemplatesApiViewDefaultContentRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesViewDefaultContentResponse> {
            return localVarFp.viewDefaultContent(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewTemplate operation in TemplatesApi.
 * @export
 * @interface TemplatesApiCreateNewTemplateRequest
 */
export type TemplatesApiCreateNewTemplateRequest = {
    
} & TemplatesCreateNewTemplateRequest

/**
 * Request parameters for deleteSpecificTemplate operation in TemplatesApi.
 * @export
 * @interface TemplatesApiDeleteSpecificTemplateRequest
 */
export type TemplatesApiDeleteSpecificTemplateRequest = {
    
    /**
    * The unique id for the template.
    * @type {string}
    * @memberof TemplatesApiDeleteSpecificTemplate
    */
    readonly templateId: string
    
}

/**
 * Request parameters for getInfo operation in TemplatesApi.
 * @export
 * @interface TemplatesApiGetInfoRequest
 */
export type TemplatesApiGetInfoRequest = {
    
    /**
    * The unique id for the template.
    * @type {string}
    * @memberof TemplatesApiGetInfo
    */
    readonly templateId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiGetInfo
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiGetInfo
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * Request parameters for listAvailableTemplates operation in TemplatesApi.
 * @export
 * @interface TemplatesApiListAvailableTemplatesRequest
 */
export type TemplatesApiListAvailableTemplatesRequest = {
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly excludeFields?: Array<string>
    
    /**
    * The number of records to return. Default value is 10. Maximum value is 1000
    * @type {number}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly count?: number
    
    /**
    * Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
    * @type {number}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly offset?: number
    
    /**
    * The Mailchimp account user who created the template.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly createdBy?: string
    
    /**
    * Restrict the response to templates created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly sinceDateCreated?: string
    
    /**
    * Restrict the response to templates created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly beforeDateCreated?: string
    
    /**
    * Limit results based on template type.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly type?: string
    
    /**
    * Limit results based on category.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly category?: string
    
    /**
    * The unique folder id.
    * @type {string}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly folderId?: string
    
    /**
    * Returns user templates sorted by the specified field.
    * @type {'date_created' | 'date_edited' | 'name'}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly sortField?: 'date_created' | 'date_edited' | 'name'
    
    /**
    * Limit results based on how the template\'s content is put together. Only templates of type `user` can be filtered by `content_type`. If you want to retrieve saved templates created with the legacy email editor, then filter `content_type` to `template`. If you\'d rather pull your saved templates for the new editor, filter to `multichannel`. For code your own templates, filter to `html`.
    * @type {'html' | 'template' | 'multichannel'}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly contentType?: 'html' | 'template' | 'multichannel'
    
    /**
    * Determines the order direction for sorted results.
    * @type {'ASC' | 'DESC'}
    * @memberof TemplatesApiListAvailableTemplates
    */
    readonly sortDir?: 'ASC' | 'DESC'
    
}

/**
 * Request parameters for updateTemplateById operation in TemplatesApi.
 * @export
 * @interface TemplatesApiUpdateTemplateByIdRequest
 */
export type TemplatesApiUpdateTemplateByIdRequest = {
    
    /**
    * The unique id for the template.
    * @type {string}
    * @memberof TemplatesApiUpdateTemplateById
    */
    readonly templateId: string
    
} & TemplatesCreateNewTemplateRequest

/**
 * Request parameters for viewDefaultContent operation in TemplatesApi.
 * @export
 * @interface TemplatesApiViewDefaultContentRequest
 */
export type TemplatesApiViewDefaultContentRequest = {
    
    /**
    * The unique id for the template.
    * @type {string}
    * @memberof TemplatesApiViewDefaultContent
    */
    readonly templateId: string
    
    /**
    * A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiViewDefaultContent
    */
    readonly fields?: Array<string>
    
    /**
    * A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
    * @type {Array<string>}
    * @memberof TemplatesApiViewDefaultContent
    */
    readonly excludeFields?: Array<string>
    
}

/**
 * TemplatesApiGenerated - object-oriented interface
 * @export
 * @class TemplatesApiGenerated
 * @extends {BaseAPI}
 */
export class TemplatesApiGenerated extends BaseAPI {
    /**
     * Create a new template for the account. Only Classic templates are supported.
     * @summary Add template
     * @param {TemplatesApiCreateNewTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public createNewTemplate(requestParameters: TemplatesApiCreateNewTemplateRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).createNewTemplate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific template.
     * @summary Delete template
     * @param {TemplatesApiDeleteSpecificTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public deleteSpecificTemplate(requestParameters: TemplatesApiDeleteSpecificTemplateRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).deleteSpecificTemplate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific template.
     * @summary Get template info
     * @param {TemplatesApiGetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public getInfo(requestParameters: TemplatesApiGetInfoRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of an account\'s available templates.
     * @summary List templates
     * @param {TemplatesApiListAvailableTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public listAvailableTemplates(requestParameters: TemplatesApiListAvailableTemplatesRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).listAvailableTemplates(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the name, HTML, or `folder_id` of an existing template.
     * @summary Update template
     * @param {TemplatesApiUpdateTemplateByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public updateTemplateById(requestParameters: TemplatesApiUpdateTemplateByIdRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplateById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the sections that you can edit in a template, including each section\'s default content.
     * @summary View default content
     * @param {TemplatesApiViewDefaultContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiGenerated
     */
    public viewDefaultContent(requestParameters: TemplatesApiViewDefaultContentRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).viewDefaultContent(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
